###########################################################
#                                                         #
#  Converting your old mudlib to work with a new parser.  #
#                                                         #
###########################################################

##################################
# Converting from pre 3.0 to 3.0 #
##################################

If you are converting from pre-3.0 game driver (2.4.5 is the most
common) to MudOS, you need to look at this section.  You should also
look at section LPC3A, it might have some things that were missed here.

Converting from pre-3.0 to MudOS is actually easier than
converting from pre-3.0 to 3.0, then to MudOS.  Let's cover
the three most common cases:

* You just got a 2.4.5 parser and mudlib, and you want to
  convert.
 
Solution:  trash your mudlib and parser; get MudOS and a working
mudlib backbone from TMI.  It will utilize most all of the
capabilities of MudOS to their fullest extent.  Genesis also
has a 3.0 driver and mudlib (called CD) available.

 
* You have an established 2.4.5 mudlib.
 
Follow the instructions in the above case accept keep your mudlib
in a safe place instead of trashing it.  Once you have the TMI mudlib
up and running on MudOS, you can piece by piece add back the
features from your 2.4.5 mudlib you want to keep - making sure that
your mudlib still works at each stage.
 
Here are some hints on converting a 2.4.5 mud to MudOS (also read
the mudlib.porting document):
 
   - File permission system.  In pre-3.0, permissions are based
     on this_player(1).  If you just want to get things working
     really quick, your best bet is to try the following
     code in master.c:
 
       int valid_read(string fn, object co, string acc_type) {
           if (!this_player(1)) return 0;
           if (this_player(1) == co) return 1;
           return (int) this_player(1)->valid_read(fn, co);
       }
       int valid_write(string fn, object co, string acc_type) {
           if (!this_player(1)) return 0;
           if (this_player(1) == co) return 1;
           return (int) this_player(1)->valid_write(fn, co);
       }
 
     Then you have to change your valid_read/valid_write in your
     player object so that the second argument is interpreted
     correctly.  (Don't ask me exactly what needs to be done,
     most 2.4.5 mudlibs have been hacked up so bad nobody has
     the original code anymore.)
 
   - Player object.  The master object's connect() function
     returns a working player object.  Try this one:
      connect() {
        object pl;
        string res;
        res = catch(pl = new("/obj/player"));
        if (res) {
           write(res + "\n");
           return new("/obj/surefireguaranteedworkingplayer");
        }
        return pl;
      }

   - catch_tell() in player object.  For flexibility all messages
     to players are sent to the catch_tell() function.  Just
     define the function:
       catch_tell(str) { receive(str); }
     By the way, it's a bad idea to use stuff like this for
     muffling shout()'s and such.  ( if (query_verb() != "shout")... }

   - user-id's.  The game no longer assumes the existence of
     wizard directories in /players, so this means you have
     to make a rule that generates uid's for player files.
     The function creator_file(str) in the master object
     should do this.
     It should return: <x> for /players/<x>/<y>;
                       get_root_uid() for /obj, /room, /secure, /closed;
                       get_bb_uid() for everything except /open;
                       and 0 for /open.
     The return value of get_root_uid() should be something like
     "Root", and the return value of get_bb_uid() should be something
     like "Backbone".  (Note the capital letters; they're important.)
 
   - The "wizard bit".  For wizlist and error message purposes,
     this bit needs to be set in the player.  In pre-3.0 game
     drivers, it checks your level for >= 21.  In 3.0 game drivers,
     it assumes the existence of a query_player_level() in the
     master object.  In MudOS, you have the efun enable_wizard().
     Just call it when the player object becomes a wizard.  There
     are two places, in the 2.4.5 mudlib, where this is the case:
     (1) When the player object is restored.
     (2) When the player object is 'promoted' to level 21 or greater.

   - ls().  It's been removed; you're supposed to simulate it
     with get_dir().  The standard simulated efun solution 
     doesn't work too well because it makes assumptions about
     your file permission system.
        The problem seems to be that valid_read/valid_write
     in 2.4.5 double as pathname expansion functions.
     This is bad.  What you should do is make a function called
     (say) resolve_path() in the player object which expands 
     file names in this fashion.  Then all your wizard soul
     commands, etc will have to use the return value of
     resolve_path() with the efuns they call.
        Once you've done this, and valid_read/valid_write
     in your player object only return 0 or 1, it's very
     likely that the standard distributed ls() simulated
     efun will work, bug the folks at TMI if it doesn't.
 
   - localcmd().  Not too bad, but you'll probably want
     it for wizards.  Put this code in the player object:
       void localcmd() {
          mixed *cmds;
          int i;
          cmds = commands();
          if (!sizeof(cmds)) return;
          write("Current local commands:\n");
          while (i < sizeof(cmds)) {
             write(cmds[i][0] + " ");
             i++;
          }
          write("\n");
       }
     Then have the "local" command call localcmd() in the wizard.

   - caller(), creator().  They've been replaced with previous_object()
     and getuid(), which behave almost the same.
 
   - create() and reset().  This is one of the Big Ones.
     Unfortunately, what it looks like you're going to have
     to do is replace every place where reset(0) is called
     with create() code, and every place where reset(1) is
     called with reset(0) code.
        Some tips on this one:  use #ifdef's with LPCA to allow
     your mud to keep running on the normal port while you
     add these features on another port.  Example:
     #ifdef LPCA
     create() {
     #else
     reset(arg) {
        if (arg) return;
     #endif
 
        If you're using std.h rooms, you'll find conversion a
     whole lot easier.  Just hack the ONE_EXIT, TWO_EXIT, etc
     macros so that they define create(), which calls reset(1),
     and reset(arg) does a  arg = !arg;
     (It seems kludgy.  It IS kludgy.  But it'll allow your mud
     to survive conversion.)
 
     Depending on how badly you need 3.0 capabilities, you may
     want to convert over before all the castles are working.
 
   - move_object().  Unquestionably the most far-reaching change.
     move_object() now only can move this_object().  You're 
     expected to call ob->move(dst) if you want to move the
     object, and ob->move(dst,1) if you want to transfer the
     object.  Fortunately, multiple inheritance makes this a
     little less painful.  Write up a component, /basic/move.c,
     which defines a move() which does just that (and returns
     1 if success).  Make all the standardized objects, such
     as /obj/monster, etc, inherit it.
        All instances of move_object() on something other than
     this_object() will have to be replaced.  Likewise transfer()
     *sigh*.  Save this one for last; it's the most heart-
     breaking task you'll face.

There are still some people out there using 2.2, believe it or not.
The only problem with 2.2 upgrades that I know of (other than the
ones I mentioned above) is that find_player() works differently
in 2.2.  It calls id() in all the player objects.  You'll have to
put set_living_name() calls in all the player objects.
 
Once you've done all this, though, you're all set.  Multiple
inheritance, virtual rooms, mappings, all that great stuff.
The effort is most definitely worth it.  And if you're going
to convert you must do it soon.  'Compatibility mode' will
be taken out of MudOS version, not too far in the future, and
probably won't last long anywhere else.


################################
# Converting from 3.0 to MudOS #
################################

Definitely not difficult, although you may find weirdness if you
are converting from a really old version, say before .40.  

One thing you have to do is change the valid_read/valid_write
functions in the master object (and anything that calls them):
 
The game no longer assumes euid's are the best way to go, instead
calling vr/vw with an object.  So, just change the string
eff_user argument in those functions to object curr_object.
Then add a local eff_user declaration to those functions.  Then
add the lines:
    eff_user = geteuid(curr_object);
    if (!eff_user) return 0;

Remember that catch_tell is always called in player objects (see
LPC2A, above).

Also check out the 'wizard bit' in LPC2A above.
 
You might also want to add the 'n', 's', 'e', 'w' etc. aliases
that were hardcoded into the driver but removed in MudOS.  You could
just add those in the player object; or you could add them
globally from a privileged object.
 
