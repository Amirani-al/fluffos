/* This is to make emacs edit this in C mode: -*-C-*- */
%include "comp_warning"

%{
#include "std.h"
#include "compiler.h"
#include "lex.h"
#include "scratchpad.h"
#include "stralloc.h"
#include "simul_efun.h"
/* inherit_file and find_object2 */
#include "simulate.h"
/* APPLY___INIT */
#include "applies.h"
/* d_flag */
#include "main.h"
/* generate_function_call, generate, pop_value */
#include "generate.h"

%line
/* down to one global :)
   bits:
      SWITCH_CONTEXT  - we're inside a switch
      LOOP_CONTEXT    - we're inside a loop
      SWITCH_STRINGS  - a string case has been found
      SWITCH_NUMBERS  - a non-zero numeric case has been found
      SWITCH_DEFAULT  - a default has been found
 */
int context;

/*
 * bison & yacc don't prototype this in y.tab.h
 */
int yyparse PROT((void));

%}
/*
 * Token definitions.
 *
 * Appearing in the precedence declarations are:
 *      '+'  '-'  '/'  '*'  '%'
 *      '&'  '|'  '<'  '>'  '^'
 *      '~'  '?'
 *
 * Other single character tokens recognized in this grammar:
 *      '{'  '}'  ','  ';'  ':'
 *      '('  ')'  '['  ']'  '$'
 */

%token L_STRING L_NUMBER L_REAL
%token L_BASIC_TYPE L_OBJECT L_FUNCTION L_TYPE_MODIFIER
%token L_DEFINED_NAME L_IDENTIFIER
%token L_EFUN

%token L_INC L_DEC
%token L_ASSIGN
%token L_LAND L_LOR
%token L_LSH L_RSH
%token L_EQ L_NE L_GE L_LE
%token L_NOT

%token L_IF L_ELSE
%token L_SWITCH L_CASE L_DEFAULT L_RANGE
%token L_WHILE L_DO L_FOR
%token L_BREAK L_CONTINUE
%token L_RETURN
%token L_ARROW L_INHERIT L_COLON_COLON
%token L_ARRAY_OPEN L_MAPPING_OPEN L_FUNCTION_OPEN L_NEW_FUNCTION_OPEN

%token L_SSCANF L_CATCH
%token L_PARSE_COMMAND L_TIME_EXPRESSION
%token L_ASM
%ifdef NEW_FUNCTIONS
%token L_PARAMETER
%endif

/*
 * 'Dangling else' shift/reduce conflict is well known...
 *  define these precedences to shut yacc up.
 */

%nonassoc LOWER_THAN_ELSE
%nonassoc L_ELSE

/*
 * Operator precedence and associativity...
 * greatly simplify the grammar.
 */

%right L_ASSIGN
%right '?'
%left L_LOR
%left L_LAND
%left '|'
%left '^'
%left '&'
%left L_EQ L_NE
%left '>' L_GE '<' L_LE
%left L_LSH L_RSH
%left '+' '-'
%left '*' '%' '/'
%right L_NOT '~'
%nonassoc L_INC L_DEC

/*
 * YYTYPE
 */
%union
{
    int number;
    float real;
    unsigned int address;       /* Address of an instruction */
    char *string;
    short type;
    struct { short type; char iscon; unsigned int addr; short len; } expr;
    struct { unsigned int addr; short num; } expr_list;
    struct { short num_arg; char is_proto; } argument;
    struct ident_hash_elem *ihe;
    struct function *funp;
#ifdef NEW_FUNCTIONS
    struct function_context_t context;
#endif
    struct parse_node *node;
}

/*
 * Type declarations.
 */

/* These hold opcodes */
%type <number> efun_override L_ASSIGN

/* Holds a variable index */
%ifdef NEW_FUNCTIONS
%type <number> L_PARAMETER
%endif

/* These hold arbitrary numbers */
%type <number> L_NUMBER constant

/* These hold a real number */
%type <real>   L_REAL

/* holds a string constant */
%type <string> L_STRING string_con1 string_con2

/* Holds the number of elements in a list and whether it must be a prototype */
%type <argument> argument_list argument

/* These hold a list of possible interpretations of an identifier */
%type <ihe> L_DEFINED_NAME

/* These hold a type */
%type <number> type optional_star type_modifier_list basic_type
%type <number> opt_basic_type L_TYPE_MODIFIER L_BASIC_TYPE L_OBJECT L_FUNCTION
%type <type> cast

/* This holds compressed and less flexible def_name information */
%type <number> L_NEW_FUNCTION_OPEN

/* holds an identifier or some sort */
%type <string> L_IDENTIFIER L_EFUN function_name identifier not_efun_ident
%type <string> new_arg_name

/* The following return a parse node */
%type <node> number real string expr0 comma_expr for_expr sscanf catch
%type <node> parse_command time_expression expr_list expr_list2 expr_list3
%type <node> expr_list4 assoc_pair expr4 lvalue function_call lvalue_list
%type <node> block local_declarations statements local_name_list
%type <node> new_local_name statement while cond do for switch case
%type <node> default return optional_else_part block_or_semi
%type <node> case_label

/* This holds a flag */
%type <number> new_arg

/* This holds a saved value of function_context */
%type <context> L_FUNCTION_OPEN
%%

all:
	program
    ;

program:
	program def possible_semi_colon
    |   /* empty */
    ;

possible_semi_colon:
	/* empty */
    |   ';'
	    {

		yywarn("Extra ';'. Ignored.");
	    }
    ;

inheritance:
	type_modifier_list L_INHERIT string_con1 ';'
	    {
		struct object *ob;
		struct inherit inherit;
		int initializer;

		ob = find_object2($3);
		if (ob == 0) {
		    inherit_file = string_copy($3);
		    /* Return back to load_object() */
		    YYACCEPT;
		}
		scratch_free($3);
		inherit.prog = ob->prog;
		inherit.function_index_offset =
		      mem_block[A_FUNCTIONS].current_size /
		      sizeof (struct function);
		inherit.variable_index_offset =
		      mem_block[A_VARIABLES].current_size /
		      sizeof (struct variable);
		add_to_mem_block(A_INHERITS, (char *)&inherit, sizeof inherit);
		copy_variables(ob->prog, $1);
		initializer = copy_functions(ob->prog, $1);
		if (initializer > 0) {
		    /* initializer is an index into the object we're
		       inheriting's function table; this finds the
		       appropriate entry in our table and generates
		       a call to it */
		    initializer += inherit.function_index_offset;
		    start_initializer();
		    generate_function_call(initializer, 0);
		    pop_value();
		    end_initializer();
		}
	    }
    ;

real:
	L_REAL
	    {
		CREATE_TYPED_NODE($$, F_REAL, TYPE_REAL);
		$$->v.real = $1;
	    }
    ;

number:
	L_NUMBER
	    {
		CREATE_TYPED_NODE($$, F_NUMBER, ($1 ? TYPE_NUMBER : TYPE_ANY));
		$$->v.number = $1;
	    }
    ;

optional_star:
	/* empty */
	    {
		$$ = 0;
	    }
    |   '*'
	    {
		$$ = TYPE_MOD_POINTER;
	    }
    ;

block_or_semi:
	block
            {
		$$ = $1;
		if (!$$) {
		    NODE_NO_LINE($$, F_RETURN);
		    NODE_NO_LINE($$->right, F_CONST0);
		}
            }
    |   ';'
	    {
		$$ = 0;
	    }
    ;

not_efun_ident: 
        L_DEFINED_NAME
            {
	      $$ = scratch_copy($1->name);
	    }
     |  L_IDENTIFIER
     |  L_ASM
            {
              $$ = scratch_copy("asm");
            }
     ;

identifier:
        not_efun_ident
     |  L_EFUN
            {
              $$ = scratch_copy("efun");
            }

def:
	type optional_star identifier '(' argument ')'
	    {
		char *p = $3;
		$3 = make_shared_string($3);
		scratch_free(p);

		if ($1 & TYPE_MOD_MASK) {
		    exact_types = $1 | $2;
		} else {
		/* force strict types - no more compat mode */

#ifdef STRICT_TYPE_CHECKING
		    exact_types = TYPE_ANY;
#else
		    exact_types = 0;
#endif
		    if (pragmas & PRAGMA_STRICT_TYPES) {
			if (strcmp($3, "create") != 0)
			    yyerror("\"#pragma strict_types\" requires type of function");
			else
			    exact_types = TYPE_VOID;
		    }
		}

		/*
		 * Define a prototype. If it is a real function, then the
		 * prototype will be replaced below.
		 */
		define_new_function($3, $5.num_arg, 0, 0,
				    NAME_UNDEFINED|NAME_PROTOTYPE, $1 | $2);
	    }
	block_or_semi
	    {
		/* Either a prototype or a block */
		if ($8) {
		    int func_start;

		    if (!($8->kind == F_RETURN) &&
			!(($8->kind == NODE_STATEMENTS) 
			  && $8->right->kind == F_RETURN)) {
			struct parse_node *replacement;
			struct parse_node *sub_node;
			NODE_NO_LINE(sub_node, F_RETURN);
			NODE_NO_LINE(sub_node->right, F_CONST0);
			NODE_NO_LINE(replacement, NODE_STATEMENTS);
			replacement->left = $8;
			replacement->right = sub_node;
			$8 = replacement;
		    }
		    func_start = generate($8);
		    if ($5.is_proto) {
			yyerror("Missing name for function argument");
		    }
		    define_new_function($3, $5.num_arg, 
			  current_number_of_locals - $5.num_arg +
			  ( max_break_stack_need -1 ) / sizeof(svalue) + 1,
			  func_start, 0, $1 | $2);
		}
		free_all_local_names();
		free_string($3);
	    }
    |   type name_list ';'
	    {
		if ($1 == 0)
		    yyerror("Missing type");
	    }
    |   inheritance
    ;

new_arg_name:
        L_IDENTIFIER
      | L_ASM
            {
		$$ = scratch_copy("asm");
            }
      | L_EFUN
            {
		$$ = scratch_copy("efun");
	    }
      | L_DEFINED_NAME
            {
		if ($1->dn.local_num != -1) {
		    yyerror("Illegal to redeclare local name");
		}
		$$ = scratch_copy($1->name);
	    }
      ;

new_arg:
        basic_type optional_star
            {
                $$ = 1;
                add_local_name("", $1 | $2);
            }
      | basic_type optional_star new_arg_name
	    {
                add_local_name($3, $1 | $2);
		scratch_free($3);
                $$ = 0;
	    }
      | new_arg_name
            {
		if (exact_types) {
		    yyerror("Missing type for argument");
		}
		add_local_name($1, TYPE_ANY);
		scratch_free($1);
		$$ = 0;
            }

argument:
	/* empty */
	    {
		$$.num_arg = 0;
                $$.is_proto = 0;
	    }
    |   argument_list
    ;

argument_list:
	new_arg
	    {
		$$.num_arg = 1;
                $$.is_proto = $1;
	    }
    |   argument_list ',' new_arg
	    {
                $$ = $1;
		$$.num_arg++;
                $$.is_proto |= $3;
	    }
    ;

type_modifier_list:
	/* empty */
	    {
		$$ = 0;
	    }
    |   L_TYPE_MODIFIER type_modifier_list
	    {
		$$ = $1 | $2;
	    }
    ;

type:
	type_modifier_list opt_basic_type
	    {
		$$ = $1 | $2;
		current_type = $$;
	    }
    ;

cast:
	'(' basic_type optional_star ')'
	    {
		$$ = $2 | $3;
	    }
    ;

opt_basic_type:
        L_BASIC_TYPE
    |   L_FUNCTION
    |   L_OBJECT
    |   /* empty */
	    {
		$$ = TYPE_UNKNOWN;
	    }
    ;

basic_type:
        L_BASIC_TYPE
    |   L_FUNCTION
    |   L_OBJECT
   ;

name_list:
	new_name
    |   new_name ',' name_list
    ;

new_name:
	optional_star identifier
	    {
		define_variable($2, current_type | $1, 0);
		scratch_free($2);
	    }
    |   optional_star identifier L_ASSIGN expr0
	    {
		struct parse_node *expr;

		if ($3 != F_ASSIGN)
		    yyerror("Only '=' is legal in initializers.");

		start_initializer();
		if (!compatible_types((current_type | $1) & TYPE_MOD_MASK,
		      $4->type)) {
		    char buff[100];

		    sprintf(buff, "Type mismatch %s when initializing %s",
			  get_two_types((current_type | $1) & TYPE_MOD_MASK,
					$4->type), $2);
		    yyerror(buff);
		}

		expr = make_branched_node(F_VOID_ASSIGN, 0, 0, $4);
		CREATE_NODE(expr->left, F_GLOBAL_LVALUE);
		expr->left->v.number = define_variable($2, current_type | $1, 0);
		generate(expr);
		end_initializer();
		scratch_free($2);
	    }
    ;

block:
	'{' local_declarations statements '}'
            {
		if ($2 && $3) {
		    NODE_NO_LINE($$, NODE_STATEMENTS);
		    $$->left = $2;
		    $$->right = $3;
		} else if ($2)
		    $$ = $2;
		else if ($3)
		    $$ = $3;
		else
		    $$ = 0;
            }
    ;

local_declarations:
	/* empty */
            {
		$$ = 0;
            }
    |   local_declarations basic_type
            {
		/* can't do this in basic_type b/c local_name_list contains
		 * expr0 which contains cast which contains basic_type
		 */
		current_type = $2;
	    }
        local_name_list ';'
            {
		if ($1 && $4) {
		    NODE_NO_LINE($$, NODE_STATEMENTS);
		    $$->left = $1;
		    $$->right = $4;
		} else if ($1)
		    $$ = $1;
		else if ($4)
		    $$ = $4;
		else
		    $$ = 0;
            }
    ;

new_local_name:
	optional_star identifier
	    {
		add_local_name($2, current_type | $1);
		scratch_free($2);
		$$ = 0;
	    }
    |   optional_star identifier L_ASSIGN expr0
	    {
		if ($3 != F_ASSIGN)
		    yyerror("Only '=' is allowed in initializers.");
		if (!compatible_types((current_type | $1) & TYPE_MOD_MASK, $4->type)) {
		    char buff[100];

		    sprintf(buff, "Type mismatch %s when initializing %s",
			  get_two_types((current_type | $1) & TYPE_MOD_MASK, $4->type), $2);
		    yyerror(buff);
		}

		$$ = make_branched_node(F_VOID_ASSIGN, 0, 0, $4);
		CREATE_NODE($$->left, F_LOCAL_LVALUE);
		$$->left->v.number = add_local_name($2, current_type | $1);
		scratch_free($2);
	    }
    ;

local_name_list:
	new_local_name
    |   new_local_name ',' local_name_list
            {
		if ($1 && $3) {
		    NODE_NO_LINE($$, NODE_STATEMENTS);
		    $$->left = $1;
		    $$->right = $3;
		} else if ($1)
		    $$ = $1;
		else if ($3)
		    $$ = $3;
		else
		    $$ = 0;
            }
    ;

statements:
	/* empty */
            {
		$$ = 0;
	    }
    |   statement statements
            {
		if ($1 && $2) {
		    NODE_NO_LINE($$, NODE_STATEMENTS);
		    $$->left = $1;
		    $$->right = $2;
		} else if ($1)
		    $$ = $1;
		else if ($2)
		    $$ = $2;
		else
		    $$ = 0;
            }
    |   error ';'
            {
		$$ = 0;
            }
    ;

statement:
	comma_expr ';'
	    {
		$$ = insert_pop_value($1);
		if (d_flag) {
		    struct parse_node *replacement;
		    NODE_NO_LINE(replacement, NODE_STATEMENTS);
		    replacement->left = $$;
		    NODE_NO_LINE(replacement->right, F_BREAK_POINT);
		    $$ = replacement;
		}
	    }
    |   cond
    |   while
    |   do
    |   for
    |   switch
    |   case
    |   default
    |   return
    |   block
    |   /* empty */ ';' 
            {
		$$ = 0;
	    }
    |   L_BREAK ';'
            {
		if (context & SWITCH_CONTEXT) {
		    NODE_NO_LINE($$, F_BREAK);
		} else
		if (context & LOOP_CONTEXT) {
		    NODE_NO_LINE($$, NODE_BREAK);
		} else {
		    yyerror("break statement outside loop");
		    $$ = 0;
		}
	    }
    |   L_CONTINUE ';'
	    {
		if (!(context & LOOP_CONTEXT))
		    yyerror("continue statement outside loop");
		NODE_NO_LINE($$, NODE_CONTINUE);
	    }
    ;

while:
       L_WHILE '(' comma_expr ')'
	    {
		$<number>1 = context;
		context = LOOP_CONTEXT;
	    }
	statement
	    {
		/* do some optimizations on the conditional expression */
		if ($3->kind == F_LT && $3->left->kind == F_LOCAL
		    && ($3->right->kind == F_LOCAL ||
			$3->right->kind == F_NUMBER))
		    $3->kind = F_LOOP_COND;
		if ($3->kind == F_POST_DEC && $3->right->kind == F_LOCAL_LVALUE) {
		    $3->kind = F_WHILE_DEC;
		    $3->v.number = $3->right->v.number;
		}

		$$ = make_branched_node(NODE_WHILE, 0, $3, $6);
		context = $<number>1;
	    }
    ;

do:
        L_DO
            {
		$<number>1 = context;
		context = LOOP_CONTEXT;
	    }
        statement L_WHILE '(' comma_expr ')' ';'
            {
		$$ = make_branched_node(NODE_DO_WHILE, 0, $3, $6);
		context = $<number>1;
	    }
    ;

for:
	L_FOR '(' for_expr ';' for_expr ';' for_expr ')'
	    {
		$<number>1 = context;
		context = LOOP_CONTEXT;
	    }
        statement
            {
		struct parse_node *sub_node;

		if ($5->kind == F_LT && $5->left->kind == F_LOCAL
		    && ($5->right->kind == F_LOCAL ||
			$5->right->kind == F_NUMBER))
		    $5->kind = F_LOOP_COND;

		$3 = insert_pop_value($3);
		$7 = insert_pop_value($7);
		if ($7 && $7->kind == F_INC && $7->right->kind == F_LOCAL_LVALUE) {
		    $7->kind = F_LOOP_INCR;
		    $7->v.number = $7->right->v.number;
		}

		NODE_NO_LINE(sub_node, NODE_FOR);
		sub_node->left = $3;
		sub_node->right = $7;
		sub_node->v.expr = $5;

		NODE_NO_LINE($$, NODE_FOR);
		$$->left = sub_node;
		$$->right = $10;

		context = $<number>1;
	      }
    ;

for_expr:
	/* EMPTY */
	    {
		CREATE_TYPED_NODE($$, F_NUMBER, TYPE_NUMBER);
		$$->v.number = 1;
	    }
    |   comma_expr
    ;

switch:
	L_SWITCH '(' comma_expr ')'
	    {
		$<number>1 = context;
		context &= LOOP_CONTEXT;
		context |= SWITCH_CONTEXT;
		$<number>2 = mem_block[A_CASES].current_size;
		current_break_stack_need += sizeof(short);
		if (current_break_stack_need > max_break_stack_need)
		    max_break_stack_need = current_break_stack_need;
	    }
	statement
	    {
		if (context & SWITCH_STRINGS) {
		    NODE_NO_LINE($$, NODE_SWITCH_STRINGS);
		} else {
		    NODE_NO_LINE($$, NODE_SWITCH_NUMBERS);
		}
		$$->left = $3;
		$$->right = $6;
		prepare_cases($$, $<number>2);
		context = $<number>1;
	    }
    ;

case:
	L_CASE case_label ':'
	    {
		if (!(context & SWITCH_CONTEXT)) {
		    yyerror("Case outside switch");
		    $$ = 0;
		    break;
		}
		$$ = $2;
		$$->v.expr = 0;

		add_to_mem_block(A_CASES, (char *)&($2), sizeof($2));
	    }
    |   L_CASE case_label L_RANGE case_label ':'
	    {
		if (!(context & SWITCH_CONTEXT)) {
		    yyerror("Case outside switch");
		    $$ = 0;
		    break;
		}
		if ( $2->kind != NODE_CASE_NUMBER 
		    || $4->kind != NODE_CASE_NUMBER )
		    yyerror("String case labels not allowed as range bounds");
		if (((int)$2->right) > ((int)$4->right)) break;

		$$ = $2;
		$$->v.expr = $4;

		add_to_mem_block(A_CASES, (char *)&($2), sizeof($2));
	    }
    ;

case_label:
	constant
	    {
		if ((context & SWITCH_STRINGS) && $1)
		    yyerror("Mixed case label list not allowed");

		if ($1) context |= SWITCH_NUMBERS;
		CREATE_NODE($$, NODE_CASE_NUMBER);
		$$->right = (struct parse_node *)$1;
	    }
    |   string_con1
	    {
		char *p = make_shared_string($1);
		scratch_free($1);
		if (context & SWITCH_NUMBERS)
		    yyerror("Mixed case label list not allowed");
		context |= SWITCH_STRINGS;
		store_prog_string(p);
		CREATE_NODE($$, NODE_CASE_STRING);
		$$->right = (struct parse_node *)p;
	    }
    ;

constant:
	constant '|' constant
	    {
		$$ = $1 | $3;
	    }
    |   constant '^' constant
	    {
		$$ = $1 ^ $3;
	    }
    |   constant '&' constant
	    {
		$$ = $1 & $3;
	    }
    |   constant L_EQ constant
	    {
		$$ = $1 == $3;
	    }
    |   constant L_NE constant
	    {
		$$ = $1 != $3;
	    }
    |   constant '>'  constant
	    {
		$$ = $1 >  $3;
	    }
    |   constant L_GE constant
	    {
		$$ = $1 >= $3;
	    }
    |   constant '<'  constant
	    {
		$$ = $1 <  $3;
	    }
    |   constant L_LE constant
	    {
		$$ = $1 <= $3;
	    }
    |   constant L_LSH constant
	    {
		$$ = $1 << $3;
	    }
    |   constant L_RSH constant
	    {
		$$ = $1 >> $3;
	    }
    |   constant '+' constant
	    {
		$$ = $1 + $3;
	    }
    |   constant '-' constant
	    {
		$$ = $1 - $3;
	    }
    |   constant '*' constant
	    {
		$$ = $1 * $3;
	    }
    |   constant '%' constant
	    {
		if ($3) $$ = $1 % $3; else yyerror("Modulo by zero");
	    }
    |   constant '/' constant
	    {
		if ($3) $$ = $1 / $3; else yyerror("Division by zero");
	    }
    |   '(' constant ')'
	    {
		$$ = $2;
	    }
    |   L_NUMBER
    |   '-' L_NUMBER
	    {
		$$ = -$2;
	    }
    |   L_NOT L_NUMBER
	    {
		$$ = !$2;
	    }
    |   '~' L_NUMBER
	    {
		$$ = ~$2;
	    }
    ;

default:
	L_DEFAULT ':'
	    {
		if (!(context & SWITCH_CONTEXT)) {
		    yyerror("Default outside switch");
		    $$ = 0;
		    break;
		}
		if (context & SWITCH_DEFAULT) {
		    yyerror("Duplicate default");
		    $$ = 0;
		    break;
		}
		CREATE_NODE($$, NODE_DEFAULT);
		$$->v.expr = 0;
		add_to_mem_block(A_CASES, (char *)&($$), sizeof($$));
		context |= SWITCH_DEFAULT;
	    }
    ;

comma_expr:
	expr0
	    {
		$$ = $1;
	    }
    |   comma_expr ',' expr0
	    {
	      $$ = make_branched_node(NODE_COMMA, $3->type,
				      insert_pop_value($1), $3);
	    }
    ;

expr0:
	lvalue L_ASSIGN expr0
	    {
		/* set this up here so we can change it below */
		$$ = make_branched_node($2, $3->type, $1, $3);

		if (exact_types && !compatible_types($1->type, $3->type) &&
		      !($1->type == TYPE_STRING && $3->type == TYPE_NUMBER &&
		      $2 == F_ADD_EQ)) {
		    char buf[1000];
		    sprintf(buf, "Bad assignment %s.", get_two_types($1->type, $3->type));
		    yyerror(buf);
		}

                if (($1->type == TYPE_REAL) && ($3->type == TYPE_NUMBER)) {
		  struct parse_node *expr;
		  expr = make_branched_node(0, 0, 0, 0);
		  expr->v.expr = $3;
		  $$->right = make_branched_node(F_TO_FLOAT, TYPE_REAL, 0, expr);
		  $$->v.number = 1;
		} else if (($1->type == TYPE_NUMBER) && ($3->type == TYPE_REAL)) {
		  struct parse_node *expr;
		  expr = make_branched_node(0, 0, 0, 0);
		  expr->v.expr = $3;
		  $$->right = make_branched_node(F_TO_INT, TYPE_NUMBER, 0, expr);
		  $$->v.number = 1;
		}
	    }
    |   error L_ASSIGN expr0
	    {
		yyerror("Illegal LHS");
		NODE_NO_LINE($$, F_CONST0);
	    }
    |   expr0 '?' expr0 ':' expr0 %prec '?'
	    {
		CREATE_TYPED_NODE($$, NODE_CONDITIONAL, TYPE_ANY);
		if (exact_types && !compatible_types($3->type, $5->type)) {
		    char buf[1000];
		    sprintf(buf, "Types in ?: do not match %s.", 
			    get_two_types($3->type, $5->type));
		    yyerror(buf);
		}
		if ($3->type == TYPE_ANY)
		    $$->type = $5->type;
		else if (TYPE($3->type, TYPE_MOD_POINTER|TYPE_ANY))
		    $$->type = $5->type;
		else
		    $$->type = $3->type;
		/* optimize if last expression did F_NOT */
		if ($1->kind == F_NOT) {
		    /* !a ? b : c  --> a ? c : b */
		    $$->left = $1->right;
		    $$->right = make_branched_node(0, 0, $5, $3);
		} else {
		    $$->left = $1;
		    $$->right = make_branched_node(0, 0, $3, $5);
		}
	    }
    |   expr0 L_LOR expr0
	    {
		$$ = make_branched_node(F_LOR,
			       ( $1->type == $3->type ) ? $1->type : TYPE_ANY,
					$1, $3);
	    }
    |   expr0 L_LAND expr0
	    {
		$$ = make_branched_node(F_LAND,
			       ( $1->type == $3->type ) ? $1->type : TYPE_ANY,
					$1, $3);
	    }
    |   expr0 '|' expr0
	    {
		$$ = binary_int_op($1, $3, F_OR, "|");
	    }
    |   expr0 '^' expr0
	    {
		$$ = binary_int_op($1, $3, F_XOR, "^");
	    }
    |   expr0 '&' expr0
	    {
		if ($1->type & $3->type & TYPE_MOD_POINTER) {
		    $$ = make_branched_node(F_AND, ($1->type == $3->type) ?
				   $1->type : TYPE_ANY | TYPE_MOD_POINTER,
					    $1, $3);
		} else 
		    $$ = binary_int_op($1, $3, F_AND, "&");
	    }
    |   expr0 L_EQ expr0
	    {
		int t1 = $1->type, t2 = $3->type;
		if (exact_types && (t1 != t2) &&
		      !((t1 & (TYPE_NUMBER | TYPE_REAL)) &&
		      (t2 & (TYPE_NUMBER | TYPE_REAL))) &&
		      (t1 != TYPE_ANY && t2 != TYPE_ANY)) {
		    char buf[1000];
		    sprintf(buf, "== always false because of incompatible types %s.",get_two_types($1->type, $3->type));
		    yyerror(buf);
		}
		/* x == 0  -> !x */
		if ($1->kind == F_NUMBER && $1->v.number == 0) {
		    NODE_NO_LINE($$, F_NOT);
		    $$->type = TYPE_NUMBER;
		    $$->right = $3;
		} else
		if ($3->kind == F_NUMBER && $3->v.number == 0) {
		    NODE_NO_LINE($$, F_NOT);
		    $$->type = TYPE_NUMBER;
		    $$->right = $1;
		} else
		    $$ = make_branched_node(F_EQ, TYPE_NUMBER, $1, $3);
	    }
    |   expr0 L_NE expr0
	    {
		int t1 = $1->type, t2 = $3->type;
		if (exact_types && (t1 != t2) &&
		      !((t1 & (TYPE_NUMBER | TYPE_REAL)) &&
		      (t2 & (TYPE_NUMBER | TYPE_REAL))) &&
		      (t1 != TYPE_ANY && t2 != TYPE_ANY)) {
		    char buf[1000];
		    sprintf(buf, "!= always true because of incompatible types %s.",get_two_types($1->type, $3->type));
		    yyerror(buf);
		}
		$$ = make_branched_node(F_NE, TYPE_NUMBER, $1, $3);
	    }
    |   expr0 '>' expr0
	    {
		$$ = make_branched_node(F_GT, TYPE_NUMBER, $1, $3);
	    }
    |   expr0 L_GE expr0
	    {
		$$ = make_branched_node(F_GE, TYPE_NUMBER, $1, $3);
	    }
    |   expr0 '<' expr0
	    {
		$$ = make_branched_node(F_LT, TYPE_NUMBER, $1, $3);
	    }
    |   expr0 L_LE expr0
	    {
		$$ = make_branched_node(F_LE, TYPE_NUMBER, $1, $3);
	    }
    |   expr0 L_LSH expr0
	    {
		$$ = binary_int_op($1, $3, F_LSH, "<<");
	    }
    |   expr0 L_RSH expr0
	    {
		$$ = binary_int_op($1, $3, F_RSH, ">>");
	    }
    |   expr0 '+' expr0 /* Type checks of this case are incomplete */
	    {
		int result_type;
		
		if ($1->type == $3->type)
		    result_type = $1->type;
		else if (($1->type & TYPE_ANY) || ($3->type & TYPE_ANY))
		    result_type = TYPE_ANY;
		else if ((TYPE($1->type, TYPE_NUMBER) && TYPE($3->type, TYPE_REAL)) ||
		      (TYPE($1->type, TYPE_REAL) && TYPE($3->type, TYPE_NUMBER)))
		    result_type = TYPE_REAL;
		else
		    result_type = TYPE_ANY;

		switch ($1->kind) {
		case F_NUMBER:
		    /* 0 + X */
		    if ($1->v.number == 0 &&
			($3->type == TYPE_NUMBER || $3->type == TYPE_REAL)) {
			$$ = $3;
			break;
		    }
		    if ($3->kind == F_NUMBER) {
			$$ = $1;
			$1->v.number += $3->v.number;
			break;
		    }
		    if ($3->kind == F_REAL) {
			$$ = $3;
			$3->v.real += $1->v.number;
			break;
		    }
		    /* swapping the nodes may help later constant folding */
		    if ($3->type != TYPE_STRING && $3->type != TYPE_ANY)
			$$ = make_branched_node(F_ADD, result_type, $3, $1);
		    else
			$$ = make_branched_node(F_ADD, result_type, $3, $1);
		    break;
		case F_REAL:
		    if ($3->kind == F_NUMBER) {
			$$ = $1;
			$1->v.real += $3->v.number;
			break;
		    }
		    if ($3->kind == F_REAL) {
			$$ = $1;
			$1->v.real += $3->v.real;
			break;
		    }
		    /* swapping the nodes may help later constant folding */
		    if ($3->type != TYPE_STRING && $3->type != TYPE_ANY)
			$$ = make_branched_node(F_ADD, result_type, $3, $1);
		    else
			$$ = make_branched_node(F_ADD, result_type, $3, $1);
		    break;
		case F_STRING:
		    if ($3->kind == F_STRING) {
			/* Combine strings */
			int n1, n2;
			char *new, *s1, *s2;
			int l;

			n1 = $1->v.number;
			n2 = $3->v.number;
			s1 = ((char**)mem_block[A_STRINGS].block)[n1];
			s2 = ((char**)mem_block[A_STRINGS].block)[n2];
			new = (char *)DXALLOC( (l = strlen(s1))+strlen(s2)+1, 53, "string add" );
			strcpy(new, s1);
			strcat(new + l, s2);
			/* free old strings (ordering may help shrink table) */
			if (n1 > n2) {
			    free_prog_string(n1); free_prog_string(n2);
			} else {
			    free_prog_string(n2); free_prog_string(n1);
			}
			$$ = $1;
			$$->v.number = store_prog_string(new);
			FREE(new);
			break;
		    }
		    $$ = make_branched_node(F_ADD, result_type, $1, $3);
		    break;
		default:
		    /* X + 0 */
		    if (($3->kind == F_NUMBER) && $3->v.number == 0 &&
			($1->type == TYPE_NUMBER || $1->type == TYPE_REAL)) {
			$$ = $1;
			break;
		    }
		    $$ = make_branched_node(F_ADD, result_type, $1, $3);
		    break;
		}
	    }
    |   expr0 '-' expr0
	    {
		int bad_arg = 0;
		int result_type;

		if (exact_types) {
		    if (!TYPE($1->type, TYPE_NUMBER) &&
			  !TYPE($1->type, TYPE_REAL) &&
			  !($1->type & TYPE_MOD_POINTER)) {
			type_error("Bad argument number 1 to '-'", $1->type);
			bad_arg++;
		    }
		    if (!TYPE($3->type, TYPE_NUMBER) &&
			  !TYPE($3->type, TYPE_REAL) &&
			  !($3->type & TYPE_MOD_POINTER)) {
			type_error("Bad argument number 2 to '-'", $3->type);
			bad_arg++;
		    }
		}
		
		result_type = TYPE_ANY;
		if (($1->type & TYPE_MOD_POINTER) || ($3->type & TYPE_MOD_POINTER))
		    result_type = TYPE_MOD_POINTER | TYPE_ANY;
		if (!($1->type & TYPE_MOD_POINTER) || !($3->type & TYPE_MOD_POINTER)) {
		    if (exact_types && result_type != TYPE_ANY && !bad_arg)
			yyerror("Arguments to '-' don't match");
		    if (($1->type & TYPE_ANY) || ($3->type & TYPE_ANY))
			result_type = TYPE_ANY;
		    else if ((TYPE($1->type, TYPE_NUMBER) && TYPE($3->type, TYPE_NUMBER)))
			result_type = TYPE_NUMBER;
		    else
			result_type = TYPE_REAL;
		}
		
		switch ($1->kind) {
		case F_NUMBER:
		    if ($1->v.number == 0) {
			$$ = make_branched_node(F_NEGATE, $3->type, 0, $3);
		    }
		    if ($3->kind == F_NUMBER) {
			$$ = $1;
			$1->v.number -= $3->v.number;
		    }
		    if ($3->kind == F_REAL) {
			$$ = $3;
			$3->v.real = $1->v.number - $3->v.real;
		    }
		    $$ = make_branched_node(F_SUBTRACT, result_type, $1, $3);
		    break;
		case F_REAL:
		    if ($3->kind == F_NUMBER) {
			$$ = $1;
			$1->v.real -= $3->v.number;
		    }
		    if ($3->kind == F_REAL) {
			$$ = $1;
			$1->v.real -= $3->v.real;
		    }
		    $$ = make_branched_node(F_SUBTRACT, result_type, $1, $3);
		    break;
		default:
		    /* optimize X-0 */
		    if ($3->kind == F_NUMBER && $3->v.number == 0) {
			$$ = $1;
			break;
		    }
		    $$ = make_branched_node(F_SUBTRACT, result_type, $1, $3);
		}
	    }
    |   expr0 '*' expr0
	    {
		int result_type;

		if (($1->type != TYPE_MAPPING) || ($3->type != TYPE_MAPPING)) {
		    if (exact_types && !TYPE($1->type, TYPE_NUMBER) && !TYPE($1->type, TYPE_REAL))
			type_error("Bad argument number 1 to '*'", $1->type);
		    if (exact_types && !TYPE($3->type, TYPE_NUMBER) && !TYPE($3->type, TYPE_REAL))
			type_error("Bad argument number 2 to '*'", $3->type);
		    if (TYPE($1->type, TYPE_NUMBER) && TYPE($3->type, TYPE_NUMBER))
			result_type = TYPE_NUMBER;
		    else
			result_type = TYPE_REAL;
		} else
		    result_type = TYPE_MAPPING;

		switch ($1->kind) {
		case F_NUMBER:
		    if ($3->kind == F_NUMBER) {
			$$ = $1;
			$$->v.number *= $3->v.number;
			break;
		    }
		    if ($3->kind == F_REAL) {
			$$ = $3;
			$3->v.real *= $1->v.number;
			break;
		    }
		    $$ = make_branched_node(F_MULTIPLY, result_type, $3, $1);
		    break;
		case F_REAL:
		    if ($3->kind == F_NUMBER) {
			$$ = $1;
			$1->v.real *= $3->v.number;
			break;
		    }
		    if ($3->kind == F_REAL) {
			$$ = $1;
			$1->v.real *= $3->v.real;
			break;
		    }
		    $$ = make_branched_node(F_MULTIPLY, result_type, $3, $1);
		    break;
		default:
		    $$ = make_branched_node(F_MULTIPLY, result_type, $1, $3);
		}
	    }
    |   expr0 '%' expr0
	    {
		$$ = binary_int_op($1, $3, F_MOD, "%");
	    }
    |   expr0 '/' expr0
	    {
		int result_type;

		if (exact_types && !TYPE($1->type, TYPE_NUMBER) && !TYPE($1->type, TYPE_REAL))
		    type_error("Bad left argument to '/'", $1->type);
		if (exact_types && !TYPE($3->type, TYPE_NUMBER) && !TYPE($3->type, TYPE_REAL))
		    type_error("Bad right argument to '/'", $3->type);
		if (TYPE($1->type, TYPE_NUMBER) && TYPE($3->type, TYPE_NUMBER))
		    result_type = TYPE_NUMBER;
		else
		    result_type = TYPE_REAL;
		/* constant expressions */
		switch ($1->kind) {
		case F_NUMBER:
		    if ($3->kind == F_NUMBER) {
			if ($3->v.number == 0) {
			    yyerror("Divide by zero in constant");
			    $$ = $1;
			    break;
			}
			$$ = $1;
			$1->v.number /= $3->v.number;
			break;
		    }
		    if ($3->kind == F_REAL) {
			if ($3->v.real == 0.0) {
			    yyerror("Divide by zero in constant");
			    $$ = $1;
			    break;
			}
			$$ = $1;
			$1->v.number /= $3->v.real;
			break;
		    }
		    $$ = make_branched_node(F_DIVIDE, result_type, $1, $3);
		    break;
		case F_REAL:
		    if ($3->kind == F_NUMBER) {
			if ($3->v.number == 0) {
			    yyerror("Divide by zero in constant");
			    $$ = $1;
			    break;
			}
			$$ = $1;
			$1->v.real /= $3->v.number;
			break;
		    }
		    if ($3->kind == F_REAL) {
			if ($3->v.real == 0.0) {
			    yyerror("Divide by zero in constant");
			    $$ = $1;
			    break;
			}
			$$ = $1;
			$1->v.real /= $3->v.real;
			break;
		    }
		    $$ = make_branched_node(F_DIVIDE, result_type, $1, $3);
		    break;
		default:
		    $$ = make_branched_node(F_DIVIDE, result_type, $1, $3);
		}
	    }
    |   cast expr0  %prec L_NOT
	    {
		$$ = $2;
		$$->type = $1;
		if (exact_types && $2->type != TYPE_ANY && $2->type != TYPE_UNKNOWN &&
		      $1 != TYPE_VOID) {
		    char tname[100];
		    char buf[1000];
		    strcpy(tname, get_type_name($2->type));
		    sprintf(buf, "Cannot cast %s to %s.", tname, get_type_name($1));
		}
	    }
    |   L_INC lvalue  %prec L_NOT  /* note lower precedence here */
	    {
		$$ = make_branched_node(F_PRE_INC, 0, 0, $2);
		if (exact_types && !TYPE($2->type, TYPE_NUMBER) && !TYPE($2->type, TYPE_REAL))
		    type_error("Bad argument to ++", $2->type);
		if (TYPE($2->type, TYPE_NUMBER))
		    $$->type = TYPE_NUMBER;
		else
		    $$->type = TYPE_REAL;
	    }
    |   L_DEC lvalue  %prec L_NOT  /* note lower precedence here */
	    {
		$$ = make_branched_node(F_PRE_DEC, 0, 0, $2);
		if (exact_types && !TYPE($2->type, TYPE_NUMBER) && !TYPE($2->type, TYPE_REAL))
		    type_error("Bad argument to --", $2->type);
		if (TYPE($2->type, TYPE_NUMBER))
		    $$->type = TYPE_NUMBER;
		else
		    $$->type = TYPE_REAL;
	    }
    |   L_NOT expr0
	    {
		if ($2->kind == F_NUMBER) {
		    $$ = $2;
		    $$->v.number = !($$->v.number);
		} else {
		    NODE_NO_LINE($$, F_NOT);
		    $$->type = TYPE_NUMBER;
		    $$->right = $2;
		}
	    }
    |   '~' expr0
	    {
		if (exact_types && !TYPE($2->type, TYPE_NUMBER))
		    type_error("Bad argument to ~", $2->type);
		if ($2->kind == F_NUMBER) {
		    $$ = $2;
		    $$->v.number = ~$$->v.number;
		} else {
		    NODE_NO_LINE($$, F_COMPL);
		    $$->type = TYPE_NUMBER;
		    $$->right = $2;
		}
	    }
    |   '-' expr0  %prec L_NOT
            {
                if (exact_types && !TYPE($2->type, TYPE_NUMBER) && !TYPE($2->type, TYPE_REAL))
		    type_error("Bad argument to unary '-'", $2->type);
		switch ($2->kind) {
		case F_NUMBER:
		    $$ = $2;
		    $$->v.number = -$$->v.number;
		    break;
		case F_REAL:
		    $$ = $2;
		    $$->v.real = -$$->v.real;
		    break;
		default:
		    $$ = make_branched_node(F_NEGATE, TYPE($2->type, TYPE_NUMBER)
					    ? TYPE_NUMBER : TYPE_REAL,
					    0, $2);
		}
	    }
    |   lvalue L_INC   /* normal precedence here */
            {
		if (exact_types && !TYPE($1->type, TYPE_NUMBER) && !TYPE($1->type, TYPE_REAL))
		    type_error("Bad argument to ++", $1->type);
		$$ = make_branched_node(F_POST_INC, TYPE($1->type, TYPE_NUMBER)
					? TYPE_NUMBER : TYPE_REAL,
					0, $1);
	    }
    |   lvalue L_DEC
	    {
		if (exact_types && !TYPE($1->type, TYPE_NUMBER) && !TYPE($1->type, TYPE_REAL))
		    type_error("Bad argument to --", $1->type);
		$$ = make_branched_node(F_POST_DEC, TYPE($1->type, TYPE_NUMBER)
					? TYPE_NUMBER : TYPE_REAL,
					0, $1);
	    }
    |   expr4
            {
	      $$ = $1;
            }
    ;

return:
	L_RETURN ';'
	    {
		if (exact_types && !TYPE(exact_types, TYPE_VOID))
		    yyerror("Non-void functions must return a value.");
		CREATE_NODE($$, F_RETURN);
		CREATE_TYPED_NODE($$->right, F_NUMBER, TYPE_NUMBER);
		$$->right->v.number = 0;
	    }
    |   L_RETURN comma_expr ';'
	    {
		if (exact_types && !compatible_types($2->type, exact_types & TYPE_MOD_MASK)) {
		    char buf[1000];
		    sprintf(buf, "Type of returned value doesn't match function return type %s.", get_two_types($2->type, exact_types & TYPE_MOD_MASK));
		    yyerror(buf);
		}
		CREATE_NODE($$, F_RETURN);
		$$->right = $2;
	    }
    ;

expr_list:
	/* empty */
	    {
		/* this is a dummy node */
		$$ = new_node();
		$$->v.number = 0;
		$$->left = $$;
		$$->right = 0;
	    }
    |   expr_list2
	    {
		$$ = new_node();
		$$->v.number = $1->kind;
		$$->left = $1->left;
		$$->right = $1;
	    }
    |   expr_list2 ','
	    {
		$$ = new_node();
		$$->v.number = $1->kind;
		$$->left = $1->left;
		$$->right = $1;
	    }
    ;

expr_list2:
	expr0
	    {
		$$ = new_node_no_line();
		$$->kind = 1;
		$$->v.expr = $1;
		$$->right = 0;
		/* we keep track of the end of the chain in the left nodes */
		$$->left = $$;
	    }
    |   expr_list2 ',' expr0
	    {
		struct parse_node *expr;

		expr = new_node_no_line();
		expr->kind = 0;
		expr->v.expr = $3;
		expr->right = 0;
		
		$1->left->right = expr;
		$1->left = expr;
		$1->kind++;
		$$ = $1;
	    }
    ;

expr_list3:
	/* empty */
	    {
		/* this is a dummy node */
		$$ = new_node_no_line();
		$$->v.number = 0;
		$$->right = 0;
	    }
    |   expr_list4
	    {
		$$ = new_node_no_line();
		$$->v.number = $1->kind;
		$$->right = $1;
	    }
    |   expr_list4 ','
	    {
		$$ = new_node_no_line();
		$$->v.number = $1->kind;
		$$->right = $1;
	    }
    ;

expr_list4:
	assoc_pair
            {
		$$ = new_node_no_line();
		$$->kind = 2;
		$$->v.expr = $1;
		$$->right = 0;
		/* we keep track of the end of the chain in the left nodes */
		$$->left = $$;
            }
    |   expr_list4 ',' assoc_pair
	    {
		struct parse_node *expr;

		expr = new_node_no_line();
		expr->kind = 0;
		expr->v.expr = $3;
		expr->right = 0;

		$1->left->right = expr;
		$1->left = expr;
		$1->kind += 2;
		$$ = $1;
	    }
    ;

assoc_pair:
	expr0 ':' expr0 
            {
                $$ = make_branched_node(NODE_ASSOC, 0, $1, $3);
            }
    ;

expr4:
	function_call
    |   lvalue
	    {
		if ($1->kind == F_GLOBAL_LVALUE)
		    $1->kind = F_GLOBAL;
		if ($1->kind == F_LOCAL_LVALUE)
		    $1->kind = F_LOCAL;
		if ($1->kind == F_INDEXED_LVALUE)
		    $1->kind = F_INDEX;
		$$ = $1;
	    }
    |   string
    |   number
    |   real
    |   '(' comma_expr ')'
	    {
		$$ = $2;
	    }
    |   catch
    |   sscanf
    |   parse_command
    |   time_expression
%ifdef NEW_FUNCTIONS
    |   L_FUNCTION '(' argument ')' block
            {
		yyerror("Anonymous functions not implemented.");
            }
    |   L_NEW_FUNCTION_OPEN ':' ')'
            {
		CREATE_TYPED_NODE($$, F_FUNCTION_CONSTRUCTOR, TYPE_FUNCTION);
		$$->right = 0;
		switch ($1 & 0xff) {
		case FP_L_VAR:
		    yyerror("Illegal to use local variable in a functional.");
		    $$->left = make_branched_node(F_CONST0, 0, 0, 0);
		    $$->v.number = FP_FUNCTIONAL;
		    break;
		case FP_G_VAR:
		    $$->left = make_branched_node(F_GLOBAL, 0, 0, 0);
		    $$->left->v.number = ($1 & ~ 0xff) >> 8;
		    $$->v.number = FP_FUNCTIONAL;
		    if (VARIABLE($$->left->v.number)->type & TYPE_MOD_HIDDEN) {
		      char buf[256];
		
		      strcpy(buf, "Illegal to use private variable '");
		      strcat(buf, VARIABLE($$->left->v.number)->name);
		      strcat(buf, "'\n");
		      yyerror(buf);
		    }
		    break;
		default:
		    $$->v.number = $1;
		    break;
		}
	    }
    |   L_NEW_FUNCTION_OPEN ',' expr_list2 ':' ')'
            {
		CREATE_TYPED_NODE($$, F_FUNCTION_CONSTRUCTOR, TYPE_FUNCTION);
		$$->v.number = $1;
		$$->right = $3;

		switch ($1 & 0xff) {
		case FP_EFUN: {
		  int *argp;
		  int f = ($1 & ~0xff) >>8;
		  int num = $3->kind;
		  int max_arg = predefs[f].max_args;
		  
		  if (num > max_arg && max_arg != -1) {
		    char bff[100];
		    sprintf(bff, "Too many arguments to %s", predefs[f].word);
		    yyerror(bff);
		  } else if (max_arg != -1 && exact_types) {
		    /*
		     * Now check all types of arguments to efuns.
		     */
		    int i, argn, tmp;
		    char buff[100];
		    struct parse_node *enode = $3;
		    argp = &efun_arg_types[predefs[f].arg_index];
		    
		    for (argn = 0; argn < num; argn++) {
		      tmp = enode->v.expr->type;
		      for (i=0; !compatible_types(argp[i], tmp) && argp[i] != 0; i++)
			;
		      if (argp[i] == 0) {
			sprintf(buff, "Bad argument %d to efun %s()",
				argn+1, predefs[f].word);
			yyerror(buff);
		      }
		      while (argp[i] != 0)
			i++;
		      argp += i + 1;
		      enode = enode->right;
		    }
		  }
		  break;
		}
		case FP_L_VAR:
		case FP_G_VAR:
		  yyerror("Can't give parameters to functional.");
		  break;
		}
	      }
      |   L_FUNCTION_OPEN expr0 ':' ')'
             {
		 if (function_context.num_locals)
		   yyerror("Illegal to use local variable in functional.");

		 $$ = make_branched_node(F_FUNCTION_CONSTRUCTOR, TYPE_FUNCTION,
					 $2, 0);
		 $$->v.number = FP_FUNCTIONAL 
		     + (function_context.num_parameters << 8);
		 function_context = $1;
             }
%else
      |   L_FUNCTION_OPEN expr0 ':' ')'
             {
		 CREATE_TYPED_NODE($$, F_FUNCTION_CONSTRUCTOR, TYPE_FUNCTION);
		 $$->v.number = ORIGIN_CALL_OTHER | 1;
		 $$->left = 0;
		 $$->right = $2;
 	    }
%endif
     |   L_FUNCTION_OPEN expr0 ',' expr0 ':' ')'
 	    {
	      $$ = make_branched_node(F_FUNCTION_CONSTRUCTOR, TYPE_FUNCTION,
				      $2, $4);
#ifdef NEW_FUNCTIONS
              if (function_context.num_parameters > 0) 
		  yyerror("Illegal use of $var in call_other function pointer.");
              function_context = $1;
	      $$->v.number = FP_CALL_OTHER;
#else
	      $$->v.number = ORIGIN_CALL_OTHER;
#endif
 	    }
    |   L_MAPPING_OPEN expr_list3 ']' ')'
	    {
	        $$ = $2;
		$$->kind = F_AGGREGATE_ASSOC;
		$$->type = TYPE_MAPPING;
	    }
    |   L_ARRAY_OPEN expr_list '}' ')'
	    {
		$$ = $2;
		$$->kind = F_AGGREGATE;
		$$->type = TYPE_MOD_POINTER | TYPE_ANY;
	    }
    ;

catch:
	L_CATCH '(' comma_expr ')'
	    {
		CREATE_TYPED_NODE($$, F_CATCH, TYPE_ANY);
		$$->right = $3;
	    }
    ;

sscanf:
	L_SSCANF '(' expr0 ',' expr0 lvalue_list ')'
	    {
	        struct parse_node *expr;
		expr = new_node_no_line();
		expr->left = $3;
		expr->right = $5;
		$$ = make_branched_node(F_SSCANF, TYPE_NUMBER,
					expr, $6);
	    }
    ;

parse_command:
	L_PARSE_COMMAND '(' expr0 ',' expr0 ',' expr0 lvalue_list ')'
	    {
	      struct parse_node *expr;
	      struct parse_node *sub_expr;

	      sub_expr = new_node_no_line();
	      sub_expr->left = $5;
	      sub_expr->right = $7;
	      expr = new_node_no_line();
	      expr->left = $3;
	      expr->right = sub_expr;
	      $$ = make_branched_node(F_PARSE_COMMAND, TYPE_NUMBER,
					expr, $8);
	    }
    ;

time_expression:
	L_TIME_EXPRESSION '(' comma_expr ')'
	    {
		$$ = make_branched_node(F_TIME_EXPRESSION, TYPE_NUMBER,
					0, $3);
	    }
    ;

lvalue_list:
	/* empty */
	    {
	        $$ = new_node_no_line();
		$$->right = 0;
	        $$->v.number = 0;
	    }
    |   ',' lvalue lvalue_list
	    {
	        $$ = $3;
	        $$->right = make_branched_node(0, 0, $2, $3->right);
		$$->v.number++;
	    }
    ;

lvalue:
        L_DEFINED_NAME
	    {
	      int i;
	      if ((i = $1->dn.local_num) != -1) {
		  CREATE_TYPED_NODE($$, F_LOCAL_LVALUE, type_of_locals[i]);
		  $$->v.number = i;
#ifdef NEW_FUNCTIONS
		/* safe even if not in a function context */
		function_context.num_locals++;
#endif
	      } else
	      if ((i = $1->dn.global_num) != -1) {
		  CREATE_TYPED_NODE($$, F_GLOBAL_LVALUE, VARIABLE(i)->type & TYPE_MOD_MASK);
		  $$->v.number = i;
		  if (VARIABLE(i)->type & TYPE_MOD_HIDDEN) {
		      char buf[256];
		
		      strcpy(buf, "Illegal to use private variable '");
		      strcat(buf, $1->name);
		      strcat(buf, "'\n");
		      yyerror(buf);
		  }
	      } else {
		char buf[256];
		
		strcpy(buf, "Undefined variable '");
		strcat(buf, $1->name);
		strcat(buf, "'\n");
		if (current_number_of_locals < MAX_LOCAL) {
		    add_local_name($1->name, TYPE_ANY);
		}
		CREATE_TYPED_NODE($$, F_LOCAL_LVALUE, TYPE_ANY);
		$$->v.number = 0;
		yyerror(buf);
	      }
	    }
    |   L_IDENTIFIER
            {
		char buf[256];

		strcpy(buf, "Undefined variable '");
		strcat(buf, $1);
		strcat(buf, "'\n");
		if (current_number_of_locals < MAX_LOCAL) {
		    add_local_name($1, TYPE_ANY);
		}
		CREATE_TYPED_NODE($$, F_LOCAL_LVALUE, TYPE_ANY);
		$$->v.number = 0;
		yyerror(buf);
		scratch_free($1);
            }
%ifdef NEW_FUNCTIONS
    |   L_PARAMETER
            {
		CREATE_TYPED_NODE($$, F_LOCAL_LVALUE, TYPE_ANY);
		$$->v.number = $1;
            }
    |   '$' '(' comma_expr ')'
            {
		yyerror("$(expression) not implemented yet.");
	    }
%endif
    |   expr4 '[' comma_expr L_RANGE comma_expr ']'
	    {
		if (exact_types) {
		    if (($1->type & TYPE_MOD_POINTER) == 0
			  && !TYPE($1->type, TYPE_STRING)
			  && !TYPE($1->type, TYPE_BUFFER))
			type_error("Bad type to indexed value", $1->type);
		    if (!TYPE($3->type, TYPE_NUMBER))
			type_error("Bad type of index", $3->type);
		    if (!TYPE($5->type, TYPE_NUMBER))
			type_error("Bad type of index", $5->type);
		}

		$$ = make_branched_node(F_RANGE, 0, $3, $5);
		$$->v.expr = $1;
		if ($1->type == TYPE_ANY)
		    $$->type = TYPE_ANY;
		else if (TYPE($1->type, TYPE_STRING))
		    $$->type = TYPE_STRING;
		else if (TYPE($1->type, TYPE_BUFFER))
		    $$->type = TYPE_BUFFER;
		else if ($1->type & TYPE_MOD_POINTER)
		    $$->type = $1->type;
		else if (exact_types)
		    type_error("Bad type of argument used for range", $1->type);
	    }
    |   expr4 '[' comma_expr ']'
	    {
		if ($1->kind == F_AGGREGATE && $3->kind == F_NUMBER) {
		    int i = $3->v.number;
		    if (i < 0 || i >= $1->v.number)
			yyerror("Illegal index to array constant.\n");
		    else {
			struct parse_node *node = $1->right;
			while (i--)
			    node = node->right;
			$$ = node->v.expr;
			break;
		    }
		}
		$$ = make_branched_node(F_INDEXED_LVALUE, 0, $1, $3);
		if (TYPE($1->type, TYPE_MAPPING) || TYPE($1->type, TYPE_FUNCTION)) {
		    $$->type = TYPE_ANY;
		} else {
		    if (exact_types) {
			if (!($1->type & TYPE_MOD_POINTER) &&
			      !TYPE($1->type, TYPE_STRING) &&
			      !TYPE($1->type, TYPE_BUFFER))
			    type_error("Bad type to indexed value", $1->type);
			if (!TYPE($3->type, TYPE_NUMBER))
			    type_error("Bad type of index", $3->type);
		    }
		    if ($1->type == TYPE_ANY)
			$$->type = TYPE_ANY;
		    else if (TYPE($1->type, TYPE_STRING))
			$$->type = TYPE_NUMBER;
		    else if (TYPE($1->type, TYPE_BUFFER))
			$$->type = TYPE_NUMBER;
		    else
			$$->type = $1->type & TYPE_MOD_MASK & ~TYPE_MOD_POINTER;
		}
	    }
    ;

string:
	string_con2
	    {
		CREATE_TYPED_NODE($$, F_STRING, TYPE_STRING);
                $$->v.number = store_prog_string($1);
		scratch_free($1);
	    }
    ;

string_con1:
	L_STRING
    |   '(' string_con1 ')'
	    {
		$$ = $2;
	    }
    |   string_con1 '+' L_STRING
	    {
		$$ = scratch_join($1, $3);
	    }
    ;

string_con2:
	L_STRING
    |   string_con2 L_STRING
	    {
		$$ = scratch_join($1, $2);
	    }
    ;

function_call:
	efun_override '(' expr_list ')'
	    {
	      $$ = validate_efun_call($1,$3);
	    }
	| L_DEFINED_NAME '(' expr_list ')'
	    {
	      int f;
	      struct function *funp;

	      $$ = $3;
	      if ((f = $1->dn.function_num) != -1) {
		  $$->kind = F_CALL_FUNCTION_BY_ADDRESS;
		  $$->v.number = f;
		  funp = FUNCTION(f);
	      
		  $$->type = validate_function_call(funp, f, $3->right);
	      } else
	      if ((f=$1->dn.simul_num) != -1) {
		  $$->kind = F_SIMUL_EFUN;
		  $$->v.number = f;
		  $$->type = (SIMUL(f)->type) & TYPE_MOD_MASK;
	      } else 
	      if ((f=$1->dn.efun_num) != -1) {
		  $$ = validate_efun_call(f, $3);
	      } else {
		/* This here is a really nasty case that only occurs with
		 * exact_types off.  The user has done something gross like:
		 *
		 * func() { int f; f(); } // if f was prototyped we wouldn't
		 * f() { }                // need this case
		 *
		 * Don't complain, just grok it.
		 */
		int f;
		struct function *funp;

		f = define_new_function($1->name, 0, 0, 0, NAME_UNDEFINED, 0);
		$$->kind = F_CALL_FUNCTION_BY_ADDRESS;
		$$->v.number = f;
		$$->type = TYPE_ANY; /* just a guess */
		funp = FUNCTION(f);
		if (exact_types) {
		  char buff[100];
		  /* prevent some errors; by making it look like an
		   * inherited function we prevent redeclaration errors
		   * if it shows up later
		   */
		  funp->flags &= ~NAME_UNDEFINED;
		  funp->flags |= NAME_INHERITED;
		  funp->type |= TYPE_MOD_VARARGS;
		  sprintf(buff, "Undefined function %.50s", $1->name);
		  yyerror(buff);
		}
	      }
	    }
	| function_name	'(' expr_list ')'
	    {
	      int f;
	      struct function *funp;
	      struct ident_hash_elem *ihe;
	      char *name = $1;
	      int is_inherited = *($1) == ':';
	      
	      if (is_inherited) name++;
	      
	      f = (ihe = lookup_ident(name)) ? ihe->dn.function_num : -1;
	      $$ = $3;
	      $$->kind = F_CALL_FUNCTION_BY_ADDRESS;
	      if (f!=-1) {
		  /* The only way this can happen is if function_name
		   * below made the function name.  The lexer would
		   * return L_DEFINED_FUNCTION instead.
		   */
		  $$->v.number = f;
		  funp = FUNCTION(f);

		  $$->type = validate_function_call(funp, f, $3->right);
	      } else {
		  if (is_inherited) {
		      f = define_new_function(name, 0, 0, 0, 
			  NAME_UNDEFINED | NAME_COLON_COLON, 0); 
		      funp = FUNCTION(f);
		      find_inherited(funp);
		  } else {
		      f = define_new_function(name, 0, 0, 0, 
					      NAME_UNDEFINED, 0);
		      funp = FUNCTION(f);
		  }
		  $$->v.number = f;
		  /*
		   * Check if this function has been defined.
		   * But, don't complain yet about functions defined
		   * by inheritance.
		   */
		  if (exact_types && (funp->flags & NAME_UNDEFINED)) {
		      char buff[100];
		      /* prevent some errors */
		      funp->flags &= ~NAME_UNDEFINED;
		      funp->type |= TYPE_MOD_VARARGS;
		      sprintf(buff, "Undefined function %.50s", $1);
		      yyerror(buff);
		  }
		  if (!(funp->flags & NAME_UNDEFINED))
		      $$->type = funp->type & TYPE_MOD_MASK;
		  else
		      $$->type = TYPE_ANY;  /* Just a guess */
	      }
	      scratch_free($1);
	    }
    |   expr4 L_ARROW identifier '(' expr_list ')'
	    {
		struct parse_node *expr, *expr2;
		$$ = $5;
		$$->kind = F_CALL_OTHER;
		$$->v.number += 2;
		$$->type = TYPE_UNKNOWN;
		  
		expr = new_node_no_line();
		expr->v.expr = $1;

		expr2 = new_node_no_line();
		CREATE_TYPED_NODE(expr2->v.expr, F_STRING, TYPE_STRING);
		expr2->v.expr->v.number = store_prog_string($3);

		/* insert the two nodes */
		expr2->right = $$->right;
		expr->right = expr2;
		$$->right = expr;
		scratch_free($3);
	    }
    |   '(' '*' comma_expr ')' '(' expr_list ')'
            {
	        struct parse_node *expr;

		$$ = $6;
		$$->kind = F_EVALUATE;
		$$->type = TYPE_UNKNOWN;
#ifdef NEW_FUNCTIONS
		expr = new_node_no_line();
		expr->v.expr = $3;
		expr->right = $$->right;
		$$->right = expr;
		$$->v.number++;
#else
                $$->v.number += 2; /* The two args from the fp split */
                $$->left = $3;
#endif
	    }
    ;

efun_override: L_EFUN L_COLON_COLON identifier {
	struct svalue *res;
	struct ident_hash_elem *ihe;

	$$ = (ihe = lookup_ident($3)) ? ihe->dn.efun_num : -1;
	if ($$ == -1) {
	    char buff[100];
	    sprintf(buff, "Unknown efun: %s", $3);
	    yyerror(buff);
	    $$ = 0;
	} else {
	  push_malloced_string(the_file_name(current_file));
	  push_constant_string($3);
	  push_constant_string(main_file_name());
	  res = safe_apply_master_ob(APPLY_VALID_OVERRIDE, 3);
	  if (!MASTER_APPROVED(res)) {
	    yyerror("Invalid simulated efunction override");
	    $$ = 0;
	  }
	}
	scratch_free($3);
      }	

function_name:
	L_IDENTIFIER
    |   L_COLON_COLON identifier
	    {
		int l = strlen($2) + 1;
		char *p;
		/* here we be a bit cute.  we put a : on the front so we
		 * don't have to strchr for it.  Here we do:
		 * "name" -> ":::name"
		 */
		$$ = scratch_realloc($2, l + 3);
		p = $$ + l;
		while (p--,l--)
		    *(p+3) = *p;
		strncpy($$, ":::", 3);
	    }
    |   L_OBJECT L_COLON_COLON identifier
	    {
		int l = strlen($3) + 1;
		char *p;
		/* "name" -> ":object::name" */
		$$ = scratch_realloc($3, l + 9);
		p = $$ + l;
		while (p--,l--)
		    *(p+9) = *p;
		strncpy($$, ":object::", 9);
	    }
    |   not_efun_ident L_COLON_COLON identifier
	    {
		int l = strlen($1);
		/* "ob" and "name" -> ":ob::name" */
		$$ = scratch_alloc(l + strlen($3) + 4);
		*($$) = ':';
		strcpy($$ + 1, $1);
		strcpy($$ + l + 1, "::");
		strcpy($$ + l + 3, $3);
		scratch_free($1);
		scratch_free($3);
	    }
    ;

cond:
        L_IF '(' comma_expr ')' statement optional_else_part
	    {
		/* x != 0 -> x */
		if ($3->kind == F_NE) {
		    if ($3->right->kind == F_NUMBER && $3->right->v.number == 0)
			$3 = $3->left;
		    else if ($3->left->kind == F_NUMBER && $3->left->v.number == 0)
			$3 = $3->right;
		}

		NODE_NO_LINE($$, NODE_IF);
		$$->v.expr = $3;
		$$->left = $5;
		$$->right = $6;
	    }
    ;

optional_else_part:
	/* empty */    %prec LOWER_THAN_ELSE
            {
		$$ = 0;
	    }
    |   L_ELSE statement
            {
		$$ = $2;
            }
    ;
%%

%line

