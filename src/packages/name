compress.c:   if ((sp - num_arg + 1)->type != T_STRING) {
compress.c:   input_file = (sp - num_arg + 1)->u.string;
compress.c:      if (((sp - num_arg + 2)->type != T_STRING)) {
compress.c:      output_file = (sp - num_arg + 2)->u.string;
compress.c:      if (!strcmp(input_file + len - strlen(GZ_EXTENSION), GZ_EXTENSION)) {
compress.c:   if ((sp - num_arg + 1)->type != T_STRING) {
compress.c:   input_file = (sp - num_arg + 1)->u.string;
compress.c:      if (((sp - num_arg + 2)->type != T_STRING)) {
compress.c:      output_file = (sp - num_arg + 2)->u.string;
compress.c:      if (strcmp(input_file + len - strlen(GZ_EXTENSION), GZ_EXTENSION)) {
compress.c:      output_file[len - strlen(GZ_EXTENSION)] = 0;
compress.c:   if (sp->type == T_STRING) {
compress.c:      input = (unsigned char*)sp->u.string;
compress.c:   } else if (sp->type == T_BUFFER) {
compress.c:      size = sp->u.buf->size;
compress.c:      input = sp->u.buf->item;
compress.c:   if (sp->type == T_BUFFER) {
compress.c:      buffer = sp->u.buf;
compress.c:   compress->next_in = buffer->item;
compress.c:   compress->avail_in = buffer->size;
compress.c:   compress->next_out = compress_buf;
compress.c:   compress->avail_out = COMPRESS_BUF_SIZE;
compress.c:   compress->zalloc = zlib_alloc;
compress.c:   compress->zfree = zlib_free;
compress.c:   compress->opaque = NULL;
compress.c:         len += COMPRESS_BUF_SIZE - compress->avail_out;
compress.c:         memcpy(output_data + pos, compress_buf, len - pos);
compress.c:         compress->next_out = compress_buf;
compress.c:         compress->avail_out = COMPRESS_BUF_SIZE;
compress.c:      memcpy(buffer->item, output_data, len);
contrib.c:  i = sp->u.ob->interactive && sp->u.ob->interactive->compressed_stream;
contrib.c:  free_object(sp->u.ob, "f_compressedp");
contrib.c:        for (ob = hashed_living[i]; ob; ob = ob->next_hashed_living) {
contrib.c:            if (!(ob->flags & O_ENABLE_COMMANDS))
contrib.c:            if (ob->flags & O_HIDDEN) {
contrib.c:    while (--nob >= 0) {
contrib.c:        vec->item[nob].type = T_OBJECT;
contrib.c:        vec->item[nob].u.ob = obtab[nob];
contrib.c:        ob = sp->u.ob;
contrib.c:    if (ob == 0 || (ob->shadowing == 0 && ob->shadowed == 0))
contrib.c:        if (ob->shadowed)
contrib.c:            ob->shadowed->shadowing = ob->shadowing;
contrib.c:        if (ob->shadowing)
contrib.c:            ob->shadowing->shadowed = ob->shadowed;
contrib.c:        ob->shadowing = ob->shadowed = 0;
contrib.c:   when I added it (added function support, etc) -Beek */
contrib.c:    if (command_giver && command_giver->interactive) {
contrib.c:        if (command_giver->interactive->iflags & NOTIFY_FAIL_FUNC) {
contrib.c:            push_funp(command_giver->interactive->default_err_message.f);
contrib.c:        } else if ((p = command_giver->interactive->default_err_message.s)) {
contrib.c:            sp->type = T_STRING;
contrib.c:            sp->subtype = STRING_SHARED;
contrib.c:            sp->u.string = p;
contrib.c:    idx = find_global_variable(current_object->prog, (sp-1)->u.string, &type, 0);
contrib.c:    if (idx == -1)
contrib.c:        error("No variable named '%s'!\n", (sp-1)->u.string);
contrib.c:    sv = &current_object->variables[idx];
contrib.c:    *sv = *sp--;
contrib.c:    free_string_svalue(sp--);
contrib.c:    idx = find_global_variable(current_object->prog, sp->u.string, &type, 0);
contrib.c:    if (idx == -1)
contrib.c:        error("No variable named '%s'!\n", sp->u.string);
contrib.c:    sv = &current_object->variables[idx];
contrib.c:    free_string_svalue(sp--);
contrib.c:        who = sp->u.ob;
contrib.c:    if (!who || who->flags & O_DESTRUCTED || !who->interactive)
contrib.c: * both. -Beek
contrib.c:    vec = allocate_empty_array(arg->size);
contrib.c:    for (i = 0; i < arg->size; i++)
contrib.c:        deep_copy_svalue(&arg->item[i], &vec->item[i]);
contrib.c:    vec = allocate_empty_class_by_size(arg->size);
contrib.c:    for (i = 0; i < arg->size; i++)
contrib.c:        deep_copy_svalue(&arg->item[i], &vec->item[i]);
contrib.c:    sv = find_for_insert(dest, &elt->values[0], 1);
contrib.c:    deep_copy_svalue(&elt->values[1], sv);
contrib.c:    map = allocate_mapping( 0 ); /* this should be fixed.  -Beek */
contrib.c:    switch (from->type) {
contrib.c:        to->u.arr = deep_copy_array( from->u.arr );
contrib.c:        depth--;
contrib.c:        to->u.arr = deep_copy_class( from->u.arr );
contrib.c:        depth--;
contrib.c:        to->u.map = deep_copy_mapping( from->u.map );
contrib.c:        depth--;
contrib.c:    int flag = (sp--)->u.number;
contrib.c:    if (sp->u.ob->flags & O_SWAPPED) 
contrib.c:        load_ob_from_swap(sp->u.ob);
contrib.c:    progp = sp->u.ob->prog;
contrib.c:    num = progp->num_functions_defined + progp->last_inherited;
contrib.c:    if (progp->num_functions_defined &&
contrib.c:        progp->function_table[progp->num_functions_defined-1].name[0]
contrib.c:        num--;
contrib.c:    while (i--) {
contrib.c:        prog = sp->u.ob->prog;
contrib.c:        if (prog->function_flags[index] & FUNC_ALIAS) {
contrib.c:            index = prog->function_flags[index] & ~FUNC_ALIAS;
contrib.c:        while (prog->function_flags[index] & FUNC_INHERITED) {
contrib.c:            high = prog->num_inherited -1;
contrib.c:                if (prog->inherit[mid].function_index_offset > index)
contrib.c:                    high = mid -1;
contrib.c:            index -= prog->inherit[low].function_index_offset;
contrib.c:            prog = prog->inherit[low].prog;
contrib.c:        index -= prog->last_inherited;
contrib.c:        funp = prog->function_table + index;
contrib.c:            if (prog->type_start && prog->type_start[index] != INDEX_START_NONE)
contrib.c:                types = &prog->argument_types[prog->type_start[index]];
contrib.c:            vec->item[i].type = T_ARRAY;
contrib.c:            subvec = vec->item[i].u.arr = allocate_empty_array(3 + funp->num_arg);
contrib.c:            subvec->item[0].type = T_STRING;
contrib.c:            subvec->item[0].subtype = STRING_SHARED;
contrib.c:            subvec->item[0].u.string = ref_string(funp->name);
contrib.c:            subvec->item[1].type = T_NUMBER;
contrib.c:            subvec->item[1].subtype = 0;
contrib.c:            subvec->item[1].u.number = funp->num_arg;
contrib.c:            get_type_name(buf, end, funp->type);
contrib.c:            subvec->item[2].type = T_STRING;
contrib.c:            subvec->item[2].subtype = STRING_SHARED;
contrib.c:            subvec->item[2].u.string = make_shared_string(buf);
contrib.c:            for (j = 0; j < funp->num_arg; j++) {
contrib.c:                    subvec->item[3 + j].type = T_STRING;
contrib.c:                    subvec->item[3 + j].subtype = STRING_SHARED;
contrib.c:                    subvec->item[3 + j].u.string = make_shared_string(buf);
contrib.c:                    subvec->item[3 + j].type = T_NUMBER;
contrib.c:                    subvec->item[3 + j].u.number = 0;
contrib.c:            vec->item[i].type = T_STRING;
contrib.c:            vec->item[i].subtype = STRING_SHARED;
contrib.c:            vec->item[i].u.string = ref_string(funp->name);
contrib.c:    for (i = 0; i < prog->num_inherited; i++) {
contrib.c:        fv_recurse(arr, idx, prog->inherit[i].prog, 
contrib.c:                   type | prog->inherit[i].type_mod, flag);
contrib.c:    for (i = 0; i < prog->num_variables_defined; i++) {
contrib.c:            arr->item[*idx + i].type = T_ARRAY;
contrib.c:            subarr = arr->item[*idx + i].u.arr = allocate_empty_array(2);
contrib.c:            subarr->item[0].type = T_STRING;
contrib.c:            subarr->item[0].subtype = STRING_SHARED;
contrib.c:            subarr->item[0].u.string = ref_string(prog->variable_table[i]);
contrib.c:            get_type_name(buf, end, prog->variable_types[i]);
contrib.c:            subarr->item[1].type = T_STRING;
contrib.c:            subarr->item[1].subtype = STRING_SHARED;
contrib.c:            subarr->item[1].u.string = make_shared_string(buf);
contrib.c:            arr->item[*idx + i].type = T_STRING;
contrib.c:            arr->item[*idx + i].subtype = STRING_SHARED;
contrib.c:            arr->item[*idx + i].u.string = ref_string(prog->variable_table[i]);
contrib.c:    *idx += prog->num_variables_defined;
contrib.c:    int flag = (sp--)->u.number;
contrib.c:    program_t *prog = sp->u.ob->prog;
contrib.c:    if (sp->u.ob->flags & O_SWAPPED)
contrib.c:        load_ob_from_swap(sp->u.ob);
contrib.c:    arr = allocate_empty_array(prog->num_variables_total);
contrib.c:   by Aleas@Nightmare, dec-94 */
contrib.c:            indent = (sp--)->u.number;
contrib.c:        wrap = (sp--)->u.number;
contrib.c:        if (indent < 0 || indent >= wrap - 1)
contrib.c:            indent = wrap - 2;
contrib.c:    cp = instr = (sp-1)->u.string;
contrib.c:                cp = savestr + ( cp - instr );
contrib.c:        if (cp - instr) {       /* starting seg, if not delimiter */
contrib.c:        sp->type = T_STRING;
contrib.c:        sp->subtype = STRING_CONSTANT;
contrib.c:        sp->u.string = "";
contrib.c:    mtab = sp->u.map->table;
contrib.c:    start = -1;
contrib.c:    for (j = i = 0, k = sp->u.map->table_size; i < num; i++) {
contrib.c:            for (elt = mtab[tmp & k]; elt; elt = elt->next)
contrib.c:                if ( elt->values->type == T_STRING && 
contrib.c:                     (elt->values + 1)->type == T_STRING &&
contrib.c:                     cp == elt->values->u.string) {
contrib.c:                    parts[i] = (elt->values + 1)->u.string;
contrib.c:                    lens[i] = SVALUE_STRLEN(elt->values + 1);
contrib.c:                    if (wrap) lens[i] = -lens[i];
contrib.c:            if (j + -lens[i] > max_string_length)
contrib.c:                lens[i] = -(-(lens[i]) - (j + -lens[i] - max_string_length));
contrib.c:            j += -lens[i];
contrib.c:            buflen += -lens[i];
contrib.c:            lens[i] -= j - max_string_length;
contrib.c:                    start = -1;
contrib.c:                        j--;
contrib.c:                        buflen--;
contrib.c:                        col += (8 - ((col - 1) % 8));
contrib.c:                            col -= space;
contrib.c:                            buflen -= space_buflen;
contrib.c:                    lens[i] -= (j - max_string_length);
contrib.c:        start = -1;
contrib.c:                memcpy(pt, p, -lens[i]);
contrib.c:                pt += -lens[i];
contrib.c:                buflen += -lens[i];
contrib.c:                space_garbage += -lens[i]; /* Number of chars due to ignored junk
contrib.c:                    start = -1;
contrib.c:                        pt--;
contrib.c:                        buflen--;
contrib.c:                        col += (8 - ((col - 1) % 8));
contrib.c:                            col -= space;
contrib.c:                            buflen -= space_buflen;
contrib.c:                n = (pt - tmp) - buflen;
contrib.c:                    cp[-1] = '\n';
contrib.c:        memcpy(cp, tmp, pt - tmp);
contrib.c:        cp += pt - tmp;
contrib.c:    if (cp - deststr != j) {
contrib.c:        fatal("Length miscalculated in terminal_colour()\n    Expected: %i Was: %i\n    String: %s\n    Indent: %i Wrap: %i\n", j, cp - deststr, sp->u.string, indent, wrap);
contrib.c:    sp->type = T_STRING;
contrib.c:    sp->subtype = STRING_MALLOC;
contrib.c:    sp->u.string = deststr;
contrib.c:        sz = p - str;
contrib.c:            plen = sz - 2;
contrib.c:            plen = sz - 3;
contrib.c:     * a bit easier.  Possibly gperf based; or is that overkill? :-)
contrib.c:     * *x -> *xes (fox -> foxes)
contrib.c:     * *s -> *ses (pass -> passes)
contrib.c:     * *ch -> *ches (church -> churches)
contrib.c:     * *sh -> *shes (brush -> brushes)
contrib.c:     * *fe -> *ves (knife -> knives)
contrib.c:     * *f -> *ves (half -> halves)
contrib.c:     * *ef -> *efs (chef -> chefs) (really a rule for a special case)
contrib.c:     * *y -> *ies (gumby -> gumbies)
contrib.c:     * *us -> *i (cactus -> cacti)
contrib.c:     * *man -> *men (foreman -> foremen)
contrib.c:     * *is -> *es (this is from gordons pluralize ... )
contrib.c:     * *o -> *s (also from gordon)
contrib.c:        switch (end[-1]) {
contrib.c:            if (end[-2] == 'f' || end[-2] == 'F') {
contrib.c:            if (end[-2] == 'e' || end[-2] == 'E')
contrib.c:            if(end[-2] == 'f' || end[-2] == 'F')
contrib.c:            if (end[-2] == 'c' || end[-2]=='s')
contrib.c:         * -- Marius, 23-Jun-2000
contrib.c:            if (end[-2] == 'u') {
contrib.c:            if (end[-2] == 'a' && end[-3] == 'm') {
contrib.c:            if (end[-2] != 'o')
contrib.c:            if (end[-2] == 'i') {
contrib.c:            if (end[-2] == 'u') {
contrib.c:            if (end[-2] == 'a' || end[-2] == 'e' || end[-2] == 'o')
contrib.c:            if (end[-2] != 'a' && end[-2] != 'e' && end[-2] != 'i'
contrib.c:                && end[-2] != 'o' && end[-2] != 'u') {
contrib.c:            if (end[-2] == 'a' || end[-2] == 'e' || end[-2] == 'o'
contrib.c:                || end[-2] == 'i' || end[-2] == 'u')
contrib.c:        plen -= (found - PLURAL_CHOP);
contrib.c:   s = pluralize(sp->u.string);
contrib.c: * Returns -1 if no privs or file doesn't exist.
contrib.c:  if (!file) return -1;
contrib.c:  if (stat(file, &st) == -1)
contrib.c:      return -1;
contrib.c:      return -2;
contrib.c:      return -1;
contrib.c:      p = buf - 1;
contrib.c:          num -= (newp - p);
contrib.c:    l = file_length(sp->u.string);
contrib.c:    str = sp->u.string;
contrib.c:            int l = str - sp->u.string;
contrib.c:            str = sp->u.string + l;
contrib.c:        numignore = sp->u.arr->size;
contrib.c:            if (sp->u.arr->item[i].type == T_STRING)
contrib.c:                ignore[i + 2] = findstring(sp->u.arr->item[i].u.string);
contrib.c:        obj = (sp-1)->u.ob;
contrib.c:        obj = sp->u.ob;
contrib.c:    prog = obj->prog;
contrib.c:    num = prog->num_functions_defined + prog->last_inherited;
contrib.c:        if (prog->function_flags[i] & (FUNC_INHERITED | FUNC_NO_CODE)) continue;
contrib.c:            if (ignore[j] == find_func_entry(prog, i)->name)
contrib.c:    if (obj == simul_efun_ob || prog->func_ref)
contrib.c:        free_array((sp--)->u.arr);
contrib.c:        ob = sp->u.ob;
contrib.c:        prog = ob->prog;
contrib.c:        if (!(ob->flags & (O_CLONE|O_SWAPPED))) {
contrib.c:            prog_size += prog->program_size;
contrib.c:            func_size += (prog->last_inherited +
contrib.c:                          prog->num_functions_defined) *sizeof(unsigned short); 
contrib.c:            func_size += prog->num_functions_defined * 
contrib.c:            string_size += prog->num_strings * sizeof(char *);
contrib.c:            var_size += prog->num_variables_defined * (sizeof(char *) + sizeof(unsigned short));
contrib.c:            inherit_size += prog->num_inherited * sizeof(inherit_t);
contrib.c:            if (prog->num_classes)
contrib.c:                class_size += prog->num_classes * sizeof(class_def_t) + (prog->classes[prog->num_classes - 1].index + prog->classes[prog->num_classes - 1].size) * sizeof(class_member_entry_t);
contrib.c:            type_size += prog->num_functions_defined * sizeof(short);
contrib.c:            if (prog->type_start) {
contrib.c:                unsigned short *ts = prog->type_start;
contrib.c:                int nfd = prog->num_functions_defined;
contrib.c:                    n += prog->function_table[i].num_arg;
contrib.c:            total_size += prog->total_size;
contrib.c:        for (ob = obj_list; ob; ob = ob->next_all) {
contrib.c:            if (ob->flags & (O_CLONE|O_SWAPPED)) continue;
contrib.c:            prog = ob->prog;
contrib.c:            prog_size += prog->program_size;
contrib.c:            func_size += (prog->last_inherited +
contrib.c:                          prog->num_functions_defined) << 1; 
contrib.c:            func_size += prog->num_functions_defined * 
contrib.c:            string_size += prog->num_strings * sizeof(char *);
contrib.c:            var_size += prog->num_variables_defined * (sizeof(char *) + sizeof(unsigned short));
contrib.c:            inherit_size += prog->num_inherited * sizeof(inherit_t);
contrib.c:            if (prog->num_classes)
contrib.c:                class_size += prog->num_classes * sizeof(class_def_t) + (prog->classes[prog->num_classes - 1].index + prog->classes[prog->num_classes - 1].size) * sizeof(class_member_entry_t);
contrib.c:            type_size += prog->num_functions_defined * sizeof(short);
contrib.c:            if (prog->type_start) {
contrib.c:                unsigned short *ts = prog->type_start;
contrib.c:                int nfd = prog->num_functions_defined;
contrib.c:                    n += prog->function_table[i].num_arg;
contrib.c:            total_size += prog->total_size;
contrib.c:/* Magician - 08May95
contrib.c:    if( (sp->u.ob->flags & O_DESTRUCTED) || !(sp->u.ob->interactive) ) {
contrib.c:        free_object(sp->u.ob, "f_remove_interactive");
contrib.c:        remove_interactive(sp->u.ob, 0);
contrib.c:        if (sp->type == T_OBJECT)
contrib.c:            free_object(sp->u.ob, "f_remove_interactive");
contrib.c:/* Zakk - August 23 1995
contrib.c:    if (!ob || ob->interactive == 0)
contrib.c:    return ob->interactive->local_port;
contrib.c:        tmp = query_ip_port(sp->u.ob);
contrib.c:        free_object(sp->u.ob, "f_query_ip_port");
contrib.c:          environ[i] = environ[env_size-1];
contrib.c:          environ[env_size-1] = NULL;
contrib.c:  time_val   = sp->u.number;
contrib.c:  timezone   = sp->u.string;
contrib.c:  retv[len-1] = '\0';
contrib.c:  time_to_check = sp->u.number;
contrib.c:  timezone = sp->u.string;
contrib.c:  push_number ((t->tm_isdst) > 0);
contrib.c:    debug_message("%s\n", sp->u.string);
contrib.c:    free_string_svalue(sp--);
contrib.c:    object_t *owner = sp->u.fp->hdr.owner;
contrib.c:    free_funp(sp->u.fp);
contrib.c:    repeat = (sp--)->u.number;    
contrib.c:        str = sp->u.string;
contrib.c:        sp->type = T_STRING;
contrib.c:        sp->subtype = STRING_CONSTANT;
contrib.c:        sp->u.string = "";
contrib.c:        sp->type = T_STRING;
contrib.c:        sp->subtype = STRING_MALLOC;
contrib.c:        sp->u.string = ret;
contrib.c:    *t += sizeof(mapping_node_t) - 2*sizeof(svalue_t);
contrib.c:    *t += memory_share(&elt->values[0]);
contrib.c:    *t += memory_share(&elt->values[1]);
contrib.c:    switch (sv->type) {
contrib.c:        switch (sv->subtype) {
contrib.c:                (1 + COUNTED_STRLEN(sv->u.string) + sizeof(malloc_block_t))/
contrib.c:                (COUNTED_REF(sv->u.string));
contrib.c:                (1 + COUNTED_STRLEN(sv->u.string) + sizeof(block_t))/
contrib.c:                (COUNTED_REF(sv->u.string));
contrib.c:        subtotal = sizeof(array_t) - sizeof(svalue_t);
contrib.c:        for (i = 0; i < sv->u.arr->size; i++)
contrib.c:            subtotal += memory_share(&sv->u.arr->item[i]);
contrib.c:        depth--;
contrib.c:        return total + subtotal/sv->u.arr->ref;
contrib.c:        mapTraverse(sv->u.map, node_share, &subtotal);
contrib.c:        depth--;
contrib.c:        return total + subtotal/sv->u.map->ref;
contrib.c:        tmp.u.arr = sv->u.fp->hdr.args;
contrib.c:            subtotal = sizeof(funptr_hdr_t) + memory_share(&tmp) - sizeof(svalue_t);
contrib.c:        switch (sv->u.fp->hdr.type) {
contrib.c:        depth--;
contrib.c:        return total + subtotal/sv->u.fp->hdr.ref;
contrib.c:        return total + (sizeof(buffer_t) + sv->u.buf->size - 1)/sv->u.buf->ref;
contrib.c:    for (i = 0; i < prog->num_inherited; i++)
contrib.c:        fms_recurse(map, ob, idx, prog->inherit[i].prog);
contrib.c:    for (i = 0; i < prog->num_variables_defined; i++) {
contrib.c:        int size = memory_share(ob->variables + *idx + i);
contrib.c:        sv.u.string = prog->variable_table[i];
contrib.c:        entry->u.number += size;
contrib.c:    *idx += prog->num_variables_defined;
contrib.c:    for (ob = obj_list; ob; ob = ob->next_all) {
contrib.c:        if (ob->flags & O_SWAPPED) 
contrib.c:        sv.u.string = ob->prog->name;
contrib.c:        if (entry->type == T_NUMBER) {
contrib.c:            entry->type = T_MAPPING;
contrib.c:            entry->u.map = allocate_mapping(8);
contrib.c:        fms_recurse(entry->u.map, ob, &idx, ob->prog);
contrib.c:        if (sp->u.ob->replaced_program)
contrib.c:            res = add_slash(sp->u.ob->replaced_program);
contrib.c:        free_object(sp->u.ob, "f_query_replaced_program");
contrib.c:        if (current_object->replaced_program)
contrib.c:            res = add_slash(sp->u.ob->replaced_program);
contrib.c:  if (event_ob->type == T_ARRAY)
contrib.c:      for (ind = 0; ind < event_ob->u.arr->size; ind++)
contrib.c:          if (event_ob->u.arr->item[ind].type != T_OBJECT ||
contrib.c:              event_ob->u.arr->item[ind].u.ob->flags &
contrib.c:                    apply (name, event_ob->u.arr->item[ind].u.ob,
contrib.c:  else if(event_ob->type == T_OBJECT)
contrib.c:      apply (name, event_ob->u.ob, numparam + 1, ORIGIN_EFUN);
contrib.c:      for (ob = event_ob->u.ob->contains; ob; ob = ob->next_inv)
contrib.c:          if (ob->flags & O_DESTRUCTED)
contrib.c:  sp--;
contrib.c:  event ((sp - num + 1), (sp - num + 2)->u.string, num - 2, (sp - num + 3));
contrib.c:    strcat(buf, low[n-10]);
contrib.c:    strcat(buf, "-");
contrib.c:  limit = sp->u.number;
contrib.c:  n = sp->u.number;
db.c:    sock = sp->u.number;
db.c:    arg = sp - num_arg + 1;
db.c:    if( sock < 1 ) error_needs_free(db_error(-1));
db.c:    if( msqlSelectDB(sock, database) == -1 ) {
db.c:	error_needs_free(db_error(-1));
db.c:    sock = handle->net.fd;
db.c:    db->my_handle = handle;
db.c:    sock = (sp-1)->u.number;
db.c:    s = sp->u.string;
db.c:    if( db->result_set != (m_result *)NULL ) {
db.c:        msqlFreeResult(db->result_set);
db.c:	db->result_set = (m_result *)NULL;
db.c:    if( msqlQuery(sock, s) == -1 ) {
db.c:	    push_malloced_string(string_copy(db->errmsg, "f_db_exec"));
db.c:    if( (db->result_set = msqlStoreResult()) == (m_result *)NULL ) {
db.c:    push_number(msqlNumRows(db->result_set));
db.c:    if (db->result_set != (MYSQL_RES *)NULL) {
db.c:	mysql_free_result(db->result_set);
db.c:	db->result_set = (MYSQL_RES *)NULL;
db.c:    if (mysql_query(db->my_handle, s)) {
db.c:	if ((tmperr = mysql_db_error(db->my_handle)) == (char *)NULL) {
db.c:	    push_malloced_string(string_copy(db->errmsg, "f_db_exec"));
db.c:    if ((db->result_set = mysql_store_result(db->my_handle)) == (MYSQL_RES *)NULL) {
db.c:    push_number(mysql_num_rows(db->result_set));
db.c:    hdl = (sp-1)->u.number;
db.c:    row = sp->u.number;
db.c:    if( db->result_set == (m_result *)NULL ) {
db.c:    if( row < 1 || row > msqlNumRows(db->result_set) )
db.c:    num_cols = msqlNumFields(db->result_set);
db.c:    msqlDataSeek(db->result_set, row-1);
db.c:    this_row = msqlFetchRow(db->result_set);
db.c:	this_field = msqlFetchField(db->result_set);
db.c:	  v->item[i] = const0u;
db.c:	    switch(this_field->type) {
db.c:		  v->item[i].type = T_NUMBER;
db.c:		  v->item[i].u.number = atoi(this_row[i]);
db.c:		  v->item[i].type = T_REAL;
db.c:		  v->item[i].u.real = atof(this_row[i]);
db.c:		  v->item[i].type = T_STRING;
db.c:		  v->item[i].subtype = STRING_MALLOC;
db.c:		  v->item[i].u.string = string_copy(this_row[i], "f_db_fetch");
db.c:		  v->item[i] = const0u;
db.c:    msqlFieldSeek(db->result_set, 0);
db.c:    if (db->result_set == (MYSQL_RES *)NULL) {
db.c:    if (row < 0 || row > mysql_num_rows(db->result_set)) {
db.c:    num_cols = mysql_num_fields(db->result_set);
db.c:	mysql_data_seek(db->result_set, row-1);
db.c:	this_row = mysql_fetch_row(db->result_set);
db.c:	this_field = (MYSQL_FIELD *)mysql_fetch_field(db->result_set);
db.c:		v->item[i] = const0u;
db.c:		v->item[i].type = T_STRING;
db.c:		v->item[i].subtype = STRING_MALLOC;
db.c:		v->item[i].u.string = string_copy(this_field->name, "f_db_fetch");
db.c:	    v->item[i] = const0u;
db.c:	    switch (this_field->type) {
db.c:		v->item[i].type = T_NUMBER;
db.c:		v->item[i].u.number = atoi(this_row[i]);
db.c:		v->item[i].type = T_REAL;
db.c:		v->item[i].u.real = atof(this_row[i]);
db.c:		v->item[i].type = T_STRING;
db.c:		v->item[i].subtype = STRING_MALLOC;
db.c:		v->item[i].u.string = string_copy(this_row[i], "f_db_fetch");
db.c:		v->item[i] = const0u;
db.c:    mysql_field_seek(db->result_set, 0);
db.c:    if( hdl == -1 || (db = valid_db_conn(hdl)) == (db_t *)NULL) {
db.c:    memcpy(db->errmsg, msqlErrMsg, len);
db.c:    db->errmsg[len] = '\n';
db.c:    db->errmsg[len + 1] = '\0';
db.c:    if ((db = valid_db_conn(hdl->net.fd)) == (db_t *)NULL) {
db.c:    memcpy(db->errmsg, err, len);
db.c:    db->errmsg[len] = '\0';
db.c:    db->handle = sock;
db.c:    db->errmsg[0] = '\0';
db.c:    db->result_set = (m_result *)NULL;
db.c:    db->result_set = (MYSQL_RES *)NULL;
db.c:        db->prior = (db_t *)NULL;
db.c:	db->next = (db_t *)NULL;
db.c:	for (tmp = dbConnList; tmp->next != (db_t *)NULL; tmp = tmp->next);
db.c:	db->prior = tmp;
db.c:	db->next = (db_t *)NULL;
db.c:	tmp->next = db;
db.c:    while( tmp->handle != sock ) {
db.c:        if( tmp->next == (db_t *)NULL ) return;
db.c:        tmp = tmp->next;
db.c:    nextdb = tmp->next;
db.c:    priordb = tmp->prior;
db.c:    if( priordb != (db_t *)NULL ) priordb->next = nextdb;
db.c:    if( nextdb != (db_t *)NULL ) nextdb->prior = priordb;
db.c:    if( tmp->result_set != (m_result *)NULL )
db.c:	msqlFreeResult(tmp->result_set);
db.c:    if (tmp->result_set != (MYSQL_RES *)NULL) {
db.c:	mysql_free_result(tmp->result_set);
db.c:    mysql_close(tmp->my_handle);
db.c:    FREE(tmp->my_handle);
db.c:    while( tmp->handle != hdl ) {
db.c:        if( tmp->next == (db_t *)NULL ) return (db_t *)NULL;
db.c:	tmp = tmp->next;
develop.c:    arg = sp - 1;
develop.c:	    flags = ob->flags;
develop.c:           if (ob->interactive) {
develop.c:                         ob->interactive->compressed_stream ? "TRUE" :
develop.c:	   outbuf_addv(&out, "total light : %d\n", ob->total_light);
develop.c:	   outbuf_addv(&out, "next_reset  : %d\n", ob->next_reset);
develop.c:	   outbuf_addv(&out, "time_of_ref : %d\n", ob->time_of_ref);
develop.c:	   outbuf_addv(&out, "ref         : %d\n", ob->ref);
develop.c:	   outbuf_addv(&out, "extra_ref   : %d\n", ob->extra_ref);
develop.c:	   outbuf_addv(&out, "swap_num    : %d\n", ob->swap_num);
develop.c:	   outbuf_addv(&out, "name        : '/%s'\n", ob->name);
develop.c:			ob->next_all ? ob->next_all->name : "NULL");
develop.c:	    for (obj2 = obj_list, i = 1; obj2; obj2 = obj2->next_all, i++)
develop.c:		if (obj2->next_all == ob) {
develop.c:				obj2->name);
develop.c:	if (ob->flags & O_SWAPPED) {
develop.c:	outbuf_addv(&out, "program ref's %d\n", ob->prog->ref);
develop.c:	outbuf_addv(&out, "Name /%s\n", ob->prog->name);
develop.c:		    ob->prog->program_size);
develop.c:		    ob->prog->last_inherited + ob->prog->num_functions_defined,
develop.c:		    (ob->prog->last_inherited + ob->prog->num_functions_defined)* sizeof(unsigned short));
develop.c:		    ob->prog->num_functions_defined,
develop.c:		    ob->prog->num_functions_defined * sizeof(function_t));
develop.c:	outbuf_addv(&out, "num strings %d\n", ob->prog->num_strings);
develop.c:	outbuf_addv(&out, "num vars %d (%d)\n", ob->prog->num_variables_defined,
develop.c:		    ob->prog->num_variables_defined * (sizeof(char *) + sizeof(short)));
develop.c:	outbuf_addv(&out, "num inherits %d (%d)\n", ob->prog->num_inherited,
develop.c:		    ob->prog->num_inherited * sizeof(inherit_t));
develop.c:	outbuf_addv(&out, "total size %d\n", ob->prog->total_size);
develop.c:	    for (i=0; i<ob->prog->num_variables_total; i++) {
develop.c:		outbuf_addv(&out, "%s: ", variable_name(ob->prog, i));
develop.c:		svalue_to_string(&ob->variables[i], &out, 2, 0, 0);
develop.c:    switch (sp->type) {
develop.c:	r = sp->u.map->ref;
develop.c:	r = sp->u.arr->ref;
develop.c:	r = sp->u.ob->ref;
develop.c:	r = sp->u.fp->hdr.ref;
develop.c:	r = sp->u.buf->ref;
develop.c:    put_number(r - 1);		/* minus 1 to compensate for being arg of
develop.c:        ret->item[i].type = T_ARRAY;
develop.c:        ret->item[i].u.arr = allocate_empty_array(2);
develop.c:        ret->item[i].u.arr->item[0].type = T_STRING;
develop.c:        ret->item[i].u.arr->item[0].subtype = STRING_SHARED;
develop.c:        ret->item[i].u.arr->item[0].u.string = make_shared_string(ob->name);
develop.c:        ret->item[i].u.arr->item[1].type = T_NUMBER;
develop.c:        ret->item[i].u.arr->item[1].u.number = ob->ref;
develop.c:        ob = ob->next_all;
develop.c:    res = dump_debugmalloc((sp - 1)->u.string, sp->u.number);
develop.c:    free_string_svalue(--sp);
develop.c:    sp->subtype = STRING_MALLOC;
develop.c:    sp->u.string = res;
develop.c:    set_malloc_mask((sp--)->u.number);
develop.c:    check_all_blocks((sp--)->u.number);
develop.c:    int ot = -1;
develop.c:    if (command_giver && command_giver->interactive) {
develop.c:        ot = command_giver->interactive->trace_level;
develop.c:        command_giver->interactive->trace_level = sp->u.number;
develop.c:    sp->u.number = ot;
develop.c:    if (command_giver && command_giver->interactive) {
develop.c:        old = command_giver->interactive->trace_prefix;
develop.c:        if (sp->type & T_STRING) {
develop.c:	    char *p = sp->u.string;
develop.c:            command_giver->interactive->trace_prefix = make_shared_string(p);
develop.c:            command_giver->interactive->trace_prefix = 0;
dwlib.c:    array_t *arr = arg->u.arr;
dwlib.c:    int size = arr->size;
dwlib.c:        dark = this_player()->check_dark(environment(this_player())->query_light());
dwlib.c:    if (no_dollars && arr->item->type == T_OBJECT && !dark && command_giver &&
dwlib.c:        command_giver->super) { 
dwlib.c:        if(!apply_low("query_light", command_giver->super, 0))
dwlib.c:        if (v && v->type == T_NUMBER && v->u.number) {
dwlib.c:    /* Check to see if there are any non-objects in the array. */ 
dwlib.c:        if ((arr->item + i)->type != T_OBJECT) {
dwlib.c:            sv = (arr->item + i);
dwlib.c:            v = apply(fun, sv->u.ob, 1, ORIGIN_EFUN);
dwlib.c:            if (!v || v->type != T_STRING) {
dwlib.c:            if(total_len + SVALUE_STRLEN(v) > max_string_length - mlen)
dwlib.c:            strncpy(str + total_len, v->u.string, (len = SVALUE_STRLEN(v)));
dwlib.c:        sv = (arr->item + i);
dwlib.c:        switch(sv->type) {
dwlib.c:                    strncpy(str + total_len, sv->u.string, len);
dwlib.c:                v = apply(fun, sv->u.ob, 1, ORIGIN_EFUN);
dwlib.c:                if (!v || v->type != T_STRING) {
dwlib.c:                    strncpy(str + total_len, v->u.string, 
dwlib.c:            if ( i < size - 2 ) {
dwlib.c:                if ( i < size - 1 ) {    
dwlib.c:            if (v && v->type == T_STRING) { 
dwlib.c:                share_and_push_string(v->u.string);
dwlib.c:                if (v && v->type == T_STRING) { 
dwlib.c:                    share_and_push_string(v->u.string);
dwlib.c:    svalue_t *sv = sp - st_num_arg + 1;
dwlib.c:    if (v && v->type == T_NUMBER) {
dwlib.c:        invis = v->u.number;
dwlib.c:    if ( v && v->type == T_NUMBER) {
dwlib.c:        referee_creator = v->u.number;
dwlib.c:    if (v && v->type == T_STRING) {
dwlib.c:        referee_name = v->u.string;
dwlib.c:        if (v && v->type == T_STRING) { 
dwlib.c:            referrer_name = v->u.string;    
dwlib.c:        if (v && v->type == T_NUMBER) { 
dwlib.c:            referrer_playtester =  v->u.number;
dwlib.c:    if (v && v->type == T_ARRAY) {
dwlib.c:        vec = v->u.arr;
dwlib.c:        size = vec->size;
dwlib.c:            item = vec->item + i;
dwlib.c:            if (strcmp(referrer_name, item->u.string) == 0) { 
dwlib.c:                strcmp("playtesters", item->u.string) == 0) { 
dwlib.c:            if (v && v->type == T_NUMBER) {
dwlib.c:                ret = v->u.number;
dwlib.c:            if (v && v->type == T_NUMBER) {
dwlib.c:                ret = v->u.number;
dwlib.c:                if (v && v->type == T_NUMBER) {
dwlib.c:                    ret = v->u.number;
dwlib.c:                if (v && v->type == T_NUMBER) {
dwlib.c:                    ret = v->u.number;
dwlib.c:    svalue_t *sv = sp - st_num_arg + 1;
dwlib.c:    CHECK_TYPES(sp-1, T_NUMBER, 1, F_MEMBER_ARRAY); */
dwlib.c:    if (sv->type == T_OBJECT && sv->u.ob) {
dwlib.c:        referee = sv->u.ob;
dwlib.c:                if (v && v->type == T_OBJECT) {
dwlib.c:                    referrer_obj = v->u.ob;
external.c:    if (--which < 0 || which > (NUM_EXTERNAL_CMDS-1) || !external_cmd[which])
external.c:    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sv) == -1)
external.c:    if (ret == -1) {
external.c:        current_object->flags |= O_EFUN_SOCKET;
external.c:        if (args->type == T_ARRAY) {
external.c:            n = args->u.arr->size;
external.c:            p = args->u.string;
external.c:        if (args->type == T_ARRAY) {
external.c:            svalue_t *sv = args->u.arr->item;
external.c:            arg = alloc_cstring(args->u.string, "external args");
external.c:    svalue_t *arg = sp - num_arg + 1;
external.c:    if (check_valid_socket("external", -1, current_object, "N/A", -1)) {
external.c:        pop_n_elems(num_arg - 1);
external.c:        sp->u.number = fd;
external.c:        pop_n_elems(num_arg - 1);
external.c:        sp->u.number = EESECURITY;
gdbm.c:    int res = db_exists( (sp-1)->u.string, sp->u.string );
gdbm.c:    if (db_query(&res, (sp-1)->u.string, sp->u.string);
gdbm.c:    switch(res->type) {
gdbm.c:	switch (respush_string(res->u.string, res->subtype);
gdbm.c:      push_array(res->u.arr);
gdbm.c:      push_number(res->u.number);
gdbm.c:      push_real(res->u.real);
gdbm.c:      push_mapping(res->u.map);
gdbm.c:      fatal("Bogus svalue in db_query(), type %d\n", res->type);
gdbm.c:  if(!(sp->type & (T_STRING|T_ARRAY|T_NUMBER|T_REAL|T_MAPPING)))
gdbm.c:  res = db_store( (sp-2)->u.string, (sp-1)->u.string, sp );
gdbm.c:  res = db_delete((sp-1)->u.string, sp->u.string);
gdbm.c:  res = db_keys((sp-st_num_arg+1)->u.string, 
gdbm.c:		  (st_num_arg == 1 ? (char *)NULL : sp->u.string));
gdbm.c:    res->ref--;			/* Ref count back to 1 */
gdbm.c:      case -1:
gdbm.c:      case -2:
gdbm.c:	ret->item[i].type = T_STRING;
gdbm.c:	ret->item[i].subtype =	STRING_MALLOC; /* Should we make it shared? */
gdbm.c:	ret->item[i].u.string = keys[i];  /* string_copy() for debugging? */
math.c:    -- coded by Truilkan 93/02/21
math.c:    sp->u.real = cos(sp->u.real);
math.c:    sp->u.real = sin(sp->u.real);
math.c:    sp->u.real = tan(sp->u.real);
math.c:    if (sp->u.real < -1.0) {
math.c:        error("math: asin(x) with (x < -1.0)\n");
math.c:    } else if (sp->u.real > 1.0) {
math.c:    sp->u.real = asin(sp->u.real);
math.c:    if (sp->u.real < -1.0) {
math.c:        error("math: acos(x) with (x < -1.0)\n");
math.c:    } else if (sp->u.real > 1.0) {
math.c:    sp->u.real = acos(sp->u.real);
math.c:    sp->u.real = atan(sp->u.real);
math.c:    if (sp->u.real < 0.0) {
math.c:    sp->u.real = sqrt(sp->u.real);
math.c:    if (sp->u.real <= 0.0) {
math.c:    sp->u.real = log(sp->u.real);
math.c:    if (sp->u.real <= 0.0) {
math.c:    sp->u.real = log10(sp->u.real);
math.c:    (sp - 1)->u.real = pow((sp - 1)->u.real, sp->u.real);
math.c:    sp--;
math.c:    sp->u.real = exp(sp->u.real);
math.c:    sp->u.real = floor(sp->u.real);
math.c:    sp->u.real = ceil(sp->u.real);
matrix.c: *  matrix.c -- matrix efuns.
matrix.c: *              2-93 : Dwayne Fontenot : original coding.
matrix.c:        matrix->item[i].type = T_REAL;
matrix.c:        matrix->item[i].u.real = identity[i];
matrix.c:    if ((sp - 1)->type != T_REAL) {
matrix.c:    if (sp->type != T_REAL) {
matrix.c:    matrix = (sp - 3)->u.arr;
matrix.c:    x = (sp - 2)->u.real;
matrix.c:    y = (sp - 1)->u.real;
matrix.c:    z = sp->u.real;
matrix.c:    sp -= 3;
matrix.c:	current_matrix[i] = matrix->item[i].u.real;
matrix.c:	matrix->item[i].u.real = final_matrix[i];
matrix.c:    if ((sp - 1)->type != T_REAL) {
matrix.c:    if (sp->type != T_REAL) {
matrix.c:    matrix = (sp - 3)->u.arr;
matrix.c:    x = (sp - 2)->u.real;
matrix.c:    y = (sp - 1)->u.real;
matrix.c:    z = sp->u.real;
matrix.c:    sp -= 3;
matrix.c:	current_matrix[i] = matrix->item[i].u.real;
matrix.c:	matrix->item[i].u.real = final_matrix[i];
matrix.c:    matrix = (sp - 1)->u.arr;
matrix.c:    angle = (sp--)->u.real;
matrix.c:	current_matrix[i] = matrix->item[i].u.real;
matrix.c:	matrix->item[i].u.real = final_matrix[i];
matrix.c:    matrix = (sp - 1)->u.arr;
matrix.c:    angle = (sp--)->u.real;
matrix.c:	current_matrix[i] = matrix->item[i].u.real;
matrix.c:	matrix->item[i].u.real = final_matrix[i];
matrix.c:    matrix = (sp - 1)->u.arr;
matrix.c:    angle = (sp--)->u.real;
matrix.c:	current_matrix[i] = matrix->item[i].u.real;
matrix.c:	matrix->item[i].u.real = final_matrix[i];
matrix.c:    if ((sp - 1)->type != T_REAL) {
matrix.c:    if (sp->type != T_REAL) {
matrix.c:    matrix = (sp - 3)->u.arr;
matrix.c:    x = (sp - 2)->u.real;
matrix.c:    y = (sp - 1)->u.real;
matrix.c:    z = sp->u.real;
matrix.c:    sp -= 3;
matrix.c:	current_matrix[i] = matrix->item[i].u.real;
matrix.c:	matrix->item[i].u.real = lookat_matrix[i];
matrix.c:    for (j = 4; j >= 0; j--) {
matrix.c:	if ((sp - j)->type != T_REAL) {
matrix.c:	    bad_arg(7 - j, F_LOOKAT_ROTATE2);
matrix.c:    matrix = (sp - 6)->u.arr;
matrix.c:    ex = (sp - 5)->u.real;
matrix.c:    ey = (sp - 4)->u.real;
matrix.c:    ez = (sp - 3)->u.real;
matrix.c:    lx = (sp - 2)->u.real;
matrix.c:    ly = (sp - 1)->u.real;
matrix.c:    lz = sp->u.real;
matrix.c:    sp -= 5;
matrix.c:    free_array((sp--)->u.arr);
matrix.c:	current_matrix[i] = matrix->item[i].u.real;
matrix.c:	matrix->item[i].u.real = lookat_matrix[i];
matrix.c:    fprintf(stderr, "%s:\t%f\t%f\t%f\n", label, v->x, v->y, v->z);
matrix.c:    xx = v->x * v->x;
matrix.c:    yy = v->y * v->y;
matrix.c:    zz = v->z * v->z;
matrix.c:	v->x /= m;
matrix.c:	v->y /= m;
matrix.c:	v->z /= m;
matrix.c:    v->x = (va->y * vb->z) - (va->z * vb->y);
matrix.c:    v->y = (va->z * vb->x) - (va->x * vb->z);
matrix.c:    v->z = (va->x * vb->y) - (va->y * vb->x);
matrix.c:    v->x = pa->x - pb->x;
matrix.c:    v->y = pa->y - pb->y;
matrix.c:    v->z = pa->z - pb->z;
matrix.c:    M[12] = -U.x * ep.x - U.y * ep.y - U.z * ep.z;
matrix.c:    M[13] = -V.x * ep.x - V.y * ep.y - V.z * ep.z;
matrix.c:    M[14] = -N.x * ep.x - N.y * ep.y - N.z * ep.z;
matrix.c:    M[12] = -U.x * ep.x - U.y * ep.y - U.z * ep.z;
matrix.c:    M[13] = -V.x * ep.x - V.y * ep.y - V.z * ep.z;
matrix.c:    M[14] = -N.x * ep.x - N.y * ep.y - N.z * ep.z;
matrix.c:    m[9] = -s;
matrix.c:    m[2] = -s;
matrix.c:    m[4] = -s;
mudlib_stats.c:        m = get_domain_stats(sp->u.string);
mudlib_stats.c:        free_string_svalue(sp--);
mudlib_stats.c:    set_author(sp->u.string);
mudlib_stats.c:    free_string_svalue(sp--);
mudlib_stats.c:        m = get_author_stats(sp->u.string);
mudlib_stats.c:        free_string_svalue(sp--);
mudlib_stats.c:	tmp = tmp->next;
mudlib_stats.c:	tmp = tmp->next;
mudlib_stats.c:    entry->next = *list;
mudlib_stats.c:    for (; list; list = list->next)
mudlib_stats.c:	if (list->length == length && strcmp(list->name, name) == 0)
mudlib_stats.c:    entry->name = make_shared_string(str);
mudlib_stats.c:    entry->length = strlen(str);
mudlib_stats.c:    entry->moves = 0;
mudlib_stats.c:    entry->heart_beats = 0;
mudlib_stats.c:    entry->errors = 0;
mudlib_stats.c:    entry->objects = 0;
mudlib_stats.c:    entry->next = NULL;
mudlib_stats.c:    entry->size_array = 0;
mudlib_stats.c:    st->domain = ob->stats.domain;
mudlib_stats.c:    st->author = ob->stats.author;
mudlib_stats.c:	st->domain = NULL;
mudlib_stats.c:	st->author = NULL;
mudlib_stats.c:	if (st->domain)
mudlib_stats.c:	    st->domain->moves += moves;
mudlib_stats.c:	if (st->author)
mudlib_stats.c:	    st->author->moves += moves;
mudlib_stats.c:	if (st->domain)
mudlib_stats.c:	    st->domain->heart_beats += hbs;
mudlib_stats.c:	if (st->author)
mudlib_stats.c:	    st->author->heart_beats += hbs;
mudlib_stats.c:	if (st->domain)
mudlib_stats.c:	    st->domain->size_array += size;
mudlib_stats.c:	if (st->author)
mudlib_stats.c:	    st->author->size_array += size;
mudlib_stats.c:	if (st->domain)
mudlib_stats.c:	    st->domain->errors += errors;
mudlib_stats.c:	if (st->author)
mudlib_stats.c:	    st->author->errors += errors;
mudlib_stats.c:	    entry->errors += errors;
mudlib_stats.c:	    entry->errors += errors;
mudlib_stats.c:	if (st->domain)
mudlib_stats.c:	    st->domain->objects += objects;
mudlib_stats.c:	if (st->author)
mudlib_stats.c:	    st->author->objects += objects;
mudlib_stats.c: *    moves -= 1%
mudlib_stats.c: *    heart_beats -= 10%
mudlib_stats.c:    for (dl = domains; dl; dl = dl->next) {
mudlib_stats.c:	dl->moves = dl->moves * 99 / 100;
mudlib_stats.c:	dl->heart_beats = dl->heart_beats * 9 / 10;
mudlib_stats.c:    for (dl = authors; dl; dl = dl->next) {
mudlib_stats.c:	dl->moves = dl->moves * 99 / 100;
mudlib_stats.c:	dl->heart_beats = dl->heart_beats * 9 / 10;
mudlib_stats.c:    for (dl = domains; dl; dl = dl->next) {
mudlib_stats.c:	EXTRA_REF(BLOCK(dl->name))++;
mudlib_stats.c:    for (dl = authors; dl; dl = dl->next) {
mudlib_stats.c:	EXTRA_REF(BLOCK(dl->name))++;
mudlib_stats.c:    push_malloced_string(add_slash(ob->name));
mudlib_stats.c:    if (ret == (svalue_t *)-1) {
mudlib_stats.c:	ob->stats.author = master_author;
mudlib_stats.c:    } else if (!ret || ret->type != T_STRING) {
mudlib_stats.c:	ob->stats.author = NULL;
mudlib_stats.c:	ob->stats.author = add_stat_entry(ret->u.string, &authors);
mudlib_stats.c:    if (master_ob == (object_t *)-1) {
mudlib_stats.c:	ob->stats.author = NULL;
mudlib_stats.c:    if (ob->stats.author) {
mudlib_stats.c:	ob->stats.author->objects--;
mudlib_stats.c:    ob->stats.author = add_stat_entry(name, &authors);
mudlib_stats.c:    if (ob->stats.author) {
mudlib_stats.c:	ob->stats.author->objects++;
mudlib_stats.c:    if (ret == 0 || ret == (svalue_t*)-1 || ret->type != T_STRING)
mudlib_stats.c:    strcpy(buff, ret->u.string);
mudlib_stats.c:	|| !current_object->uid
mudlib_stats.c:	ob->stats.domain = add_stat_entry("NONAME", &domains);
mudlib_stats.c:    push_malloced_string(add_slash(ob->name));
mudlib_stats.c:	ob->stats.domain = current_object->stats.domain;
mudlib_stats.c:    if (ret->type != T_STRING)
mudlib_stats.c:    domain_name = ret->u.string;
mudlib_stats.c:    if (strcmp(current_object->stats.domain->name, domain_name) == 0) {
mudlib_stats.c:	ob->stats.domain = current_object->stats.domain;
mudlib_stats.c:    if (strcmp(backbone_domain->name, domain_name) == 0) {
mudlib_stats.c:	ob->stats.domain = current_object->stats.domain;
mudlib_stats.c:    ob->stats.domain = add_stat_entry(domain_name, &domains);
mudlib_stats.c:    if (ret == 0 || ret == (svalue_t*)-1 || ret->type != T_STRING)
mudlib_stats.c:    strcpy(buff, ret->u.string);
mudlib_stats.c:	fprintf(f, "%s %d %d\n", list->name,
mudlib_stats.c:		list->moves, list->heart_beats);
mudlib_stats.c:	list = list->next;
mudlib_stats.c:	fscanf(f, "%d %d\n", &entry->moves, &entry->heart_beats);
mudlib_stats.c:    add_mapping_pair(ret, "moves", dl->moves);
mudlib_stats.c:    add_mapping_pair(ret, "errors", dl->errors);
mudlib_stats.c:    add_mapping_pair(ret, "heart_beats", dl->heart_beats);
mudlib_stats.c:    add_mapping_pair(ret, "array_size", dl->size_array);
mudlib_stats.c:    add_mapping_pair(ret, "objects", dl->objects);
mudlib_stats.c:	for (dl = list; dl; dl = dl->next) {
mudlib_stats.c:	    if (!strcmp(str, dl->name))	/* are these both shared strings? */
mudlib_stats.c:	    tmp->ref--;
mudlib_stats.c:    for (dl = list; dl; dl = dl->next) {
mudlib_stats.c:	lv.u.string = dl->name;  /* find_for_insert() adds a ref */
mudlib_stats.c:	s->type = T_MAPPING;
mudlib_stats.c:	s->subtype = 0;
mudlib_stats.c:	s->u.map = get_info(dl);
mudlib_stats.c:    m->ref--;
parser.c: * . he, she, it, him, her, them -> "look at tempress.  get sword.  kill her with it"
parser.c: * . compound input -> "n. e then s."
parser.c: * . where is ... "where is sword" -> "In the bag on the table"
parser.c:#define DEBUG_DEC  if (debug_parse_depth) debug_parse_depth--
parser.c:#define SHARED_STRING(x) ((x)->subtype == STRING_SHARED ? (x)->u.string : findstring((x)->u.string))
parser.c:#define NEED_REFRESH(ob) (ob->pinfo && ((ob->pinfo->flags & (PI_SETUP|PI_REFRESH)) != PI_SETUP))
parser.c:/* parse_init() - setup the object
parser.c: * parse_refresh() - refresh an object's parse data
parser.c: * parse_add_rule(verb, rule) - add a rule for a verb
parser.c: * parse_sentence(sent) - do the parsing :)
parser.c:    if (pe->error_type == ERR_ALLOCATED) {
parser.c:	MSTR_EXTRA_REF(pe->err.str)++;
parser.c:	if (best_result->ob)
parser.c:	    best_result->ob->extra_ref++;
parser.c:	if (best_result->parallel)
parser.c:	    if (best_result->res[i].func)
parser.c:		MSTR_EXTRA_REF(best_result->res[i].func)++;
parser.c:	    if (best_result->res[i].args) {
parser.c:		for (j = 0; j < best_result->res[i].num; j++)
parser.c:		    mark_svalue(((svalue_t *)best_result->res[i].args) + j);
parser.c:		/* mark best_result->res[i].args */;
parser.c:	    EXTRA_REF(BLOCK(verb_entry->real_name))++;
parser.c:	    EXTRA_REF(BLOCK(verb_entry->match_name))++;
parser.c:	    verb_entry = verb_entry->next;
parser.c:	    EXTRA_REF(BLOCK(swp->wrd))++;
parser.c:	    swp = swp->next;
parser.c:	master_user_list->extra_ref++;
parser.c:    if (!(pinfo->flags & PI_SETUP))
parser.c:    for (i = 0; i < pinfo->num_ids; i++) {
parser.c:	EXTRA_REF(BLOCK(pinfo->ids[i]))++;
parser.c:    for (i = 0; i < pinfo->num_adjs; i++) {
parser.c:	EXTRA_REF(BLOCK(pinfo->adjs[i]))++;
parser.c:    for (i = 0; i < pinfo->num_plurals; i++) {
parser.c:	EXTRA_REF(BLOCK(pinfo->plurals[i]))++;
parser.c:    int n = debug_parse_depth - 1;
parser.c:    while (n--) {
parser.c:    int i, n = b2->last;
parser.c:    b1->last = n;
parser.c:	b1->b[i] = b2->b[i];
parser.c:    bv->last = 0;
parser.c:    if (which >= bv->last) {
parser.c:	for (i = bv->last; i < which; i++)
parser.c:	    bv->b[i] = 0;
parser.c:	bv->b[which] = BV_BIT(elem);
parser.c:	bv->last = which + 1;
parser.c:	bv->b[which] |= BV_BIT(elem);
parser.c:    int n = (bv1->last < bv2->last ? bv1->last : bv2->last);
parser.c:    bv1->last = n;
parser.c:	if (bv1->b[i] &= bv2->b[i]) found = 1;
parser.c:    for (i = 0; i < bv->last; i++) {
parser.c:	unsigned int k = bv->b[i];
parser.c:    int num = (remote_flag ? num_objects : num_objects - num_people);
parser.c:    while (i--)
parser.c:	bv->b[i] = ~0;
parser.c:	bv->b[last] = BV_BIT(num) - 1;
parser.c:	bv->last = last + 1;
parser.c:	bv->last = last;
parser.c:    ret = &matches[state->num_matches++];
parser.c:    ret->first = start;
parser.c:    ret->last = end;
parser.c:    ret->token = token;
parser.c:	state->num_errors++;
parser.c:    DEBUG_PP(("State is: %x, num_errors: %i\n", state, state->num_errors));
parser.c:    if (!arr->size) {
parser.c:    table = *sarrp = CALLOCATE(arr->size, char *, 
parser.c:    for (j = 0; j < arr->size; j++) {
parser.c:	if (arr->item[j].type == T_STRING) {
parser.c:	    DEBUG_PP(("Got: %s", arr->item[j].u.string));
parser.c:	    if (arr->item[j].subtype == STRING_SHARED) {
parser.c:		table[n++] = ref_string(arr->item[j].u.string);
parser.c:		table[n++] = make_shared_string(arr->item[j].u.string);
parser.c:    if (n != arr->size)
parser.c:    swp->wrd = p;
parser.c:    swp->kind = kind;
parser.c:    swp->arg = arg;
parser.c:    swp->next = special_table[h];
parser.c:	if (swp->wrd == wrd) {
parser.c:	    *arg = swp->arg;
parser.c:	    return swp->kind;
parser.c:	swp = swp->next;
parser.c:	    if (p - wrd < 2 || *(p - 2) != '1') {
parser.c:		switch (*(p - 1)) {
parser.c:	if (ret && ret->type == T_ARRAY) {
parser.c:	    master_user_list = ret->u.arr;
parser.c:	    ret->u.arr->ref++;
parser.c:	if (ret && ret->type == T_ARRAY)
parser.c:	    num_literals = parse_copy_array(ret->u.arr, &literals);
parser.c:    if (current_object->pinfo)
parser.c:    pi = current_object->pinfo = ALLOCATE(parse_info_t, TAG_PARSER, "parse_init");
parser.c:    pi->ob = current_object;
parser.c:    pi->flags = 0;
parser.c:    if (pinfo->flags & PI_SETUP) {
parser.c:	if (pinfo->num_ids) {
parser.c:	    for (i = 0; i < pinfo->num_ids; i++)
parser.c:		free_string(pinfo->ids[i]);
parser.c:	    FREE(pinfo->ids);
parser.c:	if (pinfo->num_plurals) {
parser.c:	    for (i = 0; i < pinfo->num_plurals; i++)
parser.c:		free_string(pinfo->plurals[i]);
parser.c:	    FREE(pinfo->plurals);
parser.c:	if (pinfo->num_adjs) {
parser.c:	    for (i = 0; i < pinfo->num_adjs; i++)
parser.c:		free_string(pinfo->adjs[i]);
parser.c:	    FREE(pinfo->adjs);
parser.c:	pinfo->num_ids = pinfo->num_plurals = pinfo->num_adjs = 0;
parser.c:	pinfo->ids = pinfo->plurals = pinfo->adjs = 0;
parser.c:	if (!master_ob->pinfo)
parser.c:    if (!(pi = current_object->pinfo))
parser.c:	      current_object->name);
parser.c:    if (pi->flags & PI_SETUP) {
parser.c:	pi->flags &= PI_VERB_HANDLER;
parser.c:	pi->flags |= PI_REFRESH;
parser.c:	pi->flags &= PI_VERB_HANDLER;
parser.c:    if (pi->flags & PI_VERB_HANDLER) {
parser.c:	if (current_object->flags & O_DESTRUCTED)
parser.c:	    pi->flags |= PI_REMOTE_LIVINGS;
parser.c:    if (pinfo->flags & PI_VERB_HANDLER) {
parser.c:		verb_node_t **vn = &(v->node), *old;
parser.c:		    if ((*vn)->handler == pinfo->ob) {
parser.c:			*vn = (*vn)->next;
parser.c:		    } else vn = &((*vn)->next);
parser.c:		v = v->next;
parser.c:	for (nodep = &hash_table[i]; *nodep && ((*nodep)->flags & HV_PERM);
parser.c:	     nodep = &((*nodep)->next))
parser.c:	    next = (*nodep)->next;
parser.c:	    free_string((*nodep)->name);
parser.c:    if (pr->ob)
parser.c:	free_object(pr->ob, "free_parse_result");
parser.c:    if (pr->parallel)
parser.c:	clear_parallel_errors(&pr->parallel);
parser.c:	if (pr->res[i].func) FREE_MSTR(pr->res[i].func);
parser.c:	if (pr->res[i].args) {
parser.c:	    for (j = 0; j < pr->res[i].num; j++)
parser.c:		free_svalue(((svalue_t *)pr->res[i].args) + j, "free_parse_result");
parser.c:	    FREE(pr->res[i].args);
parser.c:    pr->ob = 0;
parser.c:    pr->parallel = 0;
parser.c:	pr->res[i].func = 0;
parser.c:	pr->res[i].args = 0;
parser.c:    n = *rule - start;
parser.c:	while (td->name) {
parser.c:	    if (STR3CMP(td->name, start)) {
parser.c:		i = td->token;
parser.c:		    if (!td->mod_legal)
parser.c:			error("Illegal to have modifiers to '%s'\n", td->name);
parser.c:		    n -= 4;
parser.c:		    while (n--) {
parser.c:			    error("Unknown modifier '%c'\n", start[-1]);
parser.c:			(*weightp)--;
parser.c:	    return -(i + 1);
parser.c:    if (ob->pinfo->flags & PI_REFRESH)
parser.c:	remove_ids(ob->pinfo);
parser.c:    if (ob->pinfo->flags & PI_SETUP && !(ob->pinfo->flags & PI_REFRESH))
parser.c:    DEBUG_P(("Interogating /%s.", ob->name));
parser.c:    if (ret && ret->type == T_ARRAY)
parser.c:	ob->pinfo->num_ids = parse_copy_array(ret->u.arr, &ob->pinfo->ids);
parser.c:	ob->pinfo->num_ids = 0;
parser.c:    if (ob->flags & O_DESTRUCTED) return;
parser.c:    ob->pinfo->flags |= PI_SETUP;
parser.c:    ob->pinfo->flags &= ~(PI_LIVING | PI_INV_ACCESSIBLE | PI_INV_VISIBLE);
parser.c:    ob->pinfo->num_adjs = 0;
parser.c:    ob->pinfo->num_plurals = 0;
parser.c:    if (ret && ret->type == T_ARRAY)
parser.c:	ob->pinfo->num_plurals = parse_copy_array(ret->u.arr, &ob->pinfo->plurals);
parser.c:	ob->pinfo->num_plurals = 0;
parser.c:    if (ob->flags & O_DESTRUCTED) return;
parser.c:    if (ret && ret->type == T_ARRAY)
parser.c:	ob->pinfo->num_adjs = parse_copy_array(ret->u.arr, &ob->pinfo->adjs);
parser.c:	ob->pinfo->num_adjs = 0;
parser.c:    if (ob->flags & O_DESTRUCTED) return;
parser.c:	ob->pinfo->flags |= PI_LIVING;
parser.c:    if (ob->flags & O_DESTRUCTED) return;
parser.c:	ob->pinfo->flags |= PI_INV_ACCESSIBLE;
parser.c:    if (ob->flags & O_DESTRUCTED) return;
parser.c:	ob->pinfo->flags |= PI_INV_VISIBLE;
parser.c:    return ob->contains;
parser.c:    if (ret && ret != (svalue_t *)-1 && ret->type == T_OBJECT)
parser.c:	return ret->u.ob;
parser.c:    return sibling->next_inv;
parser.c:    if (ret && ret != (svalue_t *)-1 && ret->type == T_OBJECT)
parser.c:	return ret->u.ob;
parser.c:    return ob->super;
parser.c:    if (ret && ret != (svalue_t *)-1 && ret->type == T_OBJECT)
parser.c:	return ret->u.ob;
parser.c:    if (ob->flags & O_DESTRUCTED) return;
parser.c:    if (ob->pinfo) {
parser.c:	if (!(ob->pinfo->flags & PI_INV_VISIBLE))
parser.c:	if (!(ob->pinfo->flags & PI_INV_ACCESSIBLE))
parser.c:    for (i = 0; i < arr->size; i++) {
parser.c:	if (arr->item[i].type == T_ARRAY) {
parser.c:		add_objects_from_array(arr->item[i].u.arr, f);
parser.c:	if (arr->item[i].type == T_OBJECT &&
parser.c:	    !((ob = arr->item[i].u.ob)->flags & O_DESTRUCTED)) {
parser.c:	    if (ob->pinfo) {
parser.c:		last_flags = ob->pinfo->flags;
parser.c:    for (i = 0; i < arr->size; i++) {
parser.c:	if (arr->item[i].type == T_ARRAY)
parser.c:	    get_objects_from_array(arr->item[i].u.arr);
parser.c:	if (arr->item[i].type != T_OBJECT) continue;
parser.c:	ob = arr->item[i].u.ob;
parser.c:	if (ob->flags & O_DESTRUCTED) continue;
parser.c:    if (ob->flags & O_DESTRUCTED) return;
parser.c:	if (he->name == str)
parser.c:	he = he->next;
parser.c:    he->name = ref_string(str);
parser.c:    bitvec_zero(&he->pv.noun);
parser.c:    bitvec_zero(&he->pv.plural);
parser.c:    bitvec_zero(&he->pv.adj);
parser.c:    he->next = hash_table[h];
parser.c:    he->flags = 0;
parser.c:	if (he->name == str) {
parser.c:	    he->flags |= HV_NICKNAME;
parser.c:	he = he->next;
parser.c:    he->name = ref_string(str);
parser.c:    bitvec_zero(&he->pv.noun);
parser.c:    bitvec_zero(&he->pv.plural);
parser.c:    bitvec_zero(&he->pv.adj);
parser.c:    he->next = hash_table[h];
parser.c:    he->flags = HV_NICKNAME;
parser.c:    parse_info_t *pi = ob->pinfo;
parser.c:    DEBUG_PP(("add_to_hash_table: /%s", ob->name));
parser.c:    for (i = 0; i < pi->num_ids; i++) {
parser.c:	he = add_hash_entry(pi->ids[i]);
parser.c:	he->flags |= HV_NOUN;
parser.c:	bitvec_set(&he->pv.noun, index);
parser.c:    for (i = 0; i < pi->num_plurals; i++) {
parser.c:	he = add_hash_entry(pi->plurals[i]);
parser.c:	he->flags |= HV_PLURAL;
parser.c:	bitvec_set(&he->pv.plural, index);
parser.c:    for (i = 0; i < pi->num_adjs; i++) {
parser.c:	he = add_hash_entry(pi->adjs[i]);
parser.c:	he->flags |= HV_ADJ;
parser.c:	bitvec_set(&he->pv.adj, index);
parser.c:    if (pi->flags & PI_LIVING)
parser.c:    for (i = 0; i < master_user_list->size; i++) {
parser.c:	if (master_user_list->item[i].type == T_OBJECT
parser.c:	    && (ob = master_user_list->item[i].u.ob)->pinfo
parser.c:	    DEBUG_PP(("adding: /%s", ob->name));
parser.c: * pointer -> index 
parser.c:    for (i = 0; i < map->table_size; i++) {
parser.c:	for (mn = map->table[i]; mn; mn = mn->next) {
parser.c:	    if (mn->values[0].type == T_STRING) {
parser.c:		hash_entry_t *he = add_hash_entry(mn->values[0].u.string);
parser.c:		he->flags |= HV_NICKNAME;
parser.c:	if (!parse_user || parse_user->flags & O_DESTRUCTED)
parser.c:    me_object = -1;
parser.c:    he->flags |= HV_ADJ;
parser.c:    bitvec_copy(&he->pv.adj, &my_objects);
parser.c:    for (i = 0; i < master_user_list->size; i++) {
parser.c:	if (master_user_list->item[i].type != T_OBJECT) continue;
parser.c:	ob = master_user_list->item[i].u.ob;
parser.c:	if (!(ob->pinfo))
parser.c:	    if (env && env->pinfo && !(env->pinfo->flags & PI_INV_VISIBLE))
parser.c:/* 0000 */ -1,  /* 0001 */  0,  /* 0010 */  1, /* 0011 */ -1,
parser.c:/* 0100 */  2,  /* 0101 */ -1,  /* 0110 */ -1, /* 0111 */ -1,
parser.c:/* 1000 */  3,  /* 1001 */ -1,  /* 1010 */ -1, /* 1011 */ -1,
parser.c:/* 1100 */ -1,  /* 1101 */ -1,  /* 1110 */ -1, /* 1111 */ -1
parser.c:    int i, res = -1;
parser.c:    for (i = 0; i < bv->last; i++) {
parser.c:	if (bv->b[i]) {
parser.c:	    if (res != -1) return -1;
parser.c:    if (res < 0) return -1;
parser.c:    tmp = bv->b[res];
parser.c:	    return -1;
parser.c:	    return -1;
parser.c:	    return -1;
parser.c:    if (tmp == -1) return tmp;
parser.c:    DEBUG_PP((" -> %i", res));
parser.c:    if (ob->flags & O_DESTRUCTED || 
parser.c:	|| ret->type != T_STRING) {
parser.c:    return strput(start, end, ret->u.string);
parser.c:	end--;
parser.c:    num = end - p + 1;
parser.c:	num = limit - str - 1;
parser.c:	end--;
parser.c:    push_malloced_string(str = new_string(end - p + 1, "push_words"));
parser.c:    if (p->error_type == ERR_ALLOCATED) {
parser.c:	FREE_MSTR(p->err.str);
parser.c:    p->error_type = 0;
parser.c:    he->flags &= ~HV_NICKNAME;
parser.c:    sv = find_string_in_mapping(parse_nicks, he->name);
parser.c:    if (sv->type != T_OBJECT) return;
parser.c:    ob = sv->u.ob;
parser.c:    if (ob->flags & O_DESTRUCTED) return;
parser.c:    if (ob->pinfo == 0) return;
parser.c:	    he->flags |= HV_NOUN;
parser.c:	    bitvec_set(&he->pv.noun, i);
parser.c:    int start = state->word_index;
parser.c:    all_objects(&objects, parse_vn->handler->pinfo->flags & PI_REMOTE_LIVINGS);
parser.c:	if (state->word_index == num_words)
parser.c:	str = words[state->word_index++].string;
parser.c:	    if (state->word_index < num_words &&
parser.c:		check_special_word(words[state->word_index].string, &tmp) == SW_OF) {
parser.c:		state->word_index++;
parser.c:			       start, state->word_index - 1);
parser.c:		bitvec_copy(&mp->val.obs, &objects);
parser.c:		mp->ordinal = 0;
parser.c:			       start, state->word_index - 1);
parser.c:		if (me_object != -1) {
parser.c:				   start, state->word_index - 1);
parser.c:		    bitvec_zero(&mp->val.obs);
parser.c:		    bitvec_set(&mp->val.obs, me_object);
parser.c:		    mp->ordinal = 0;
parser.c:	    if (hnode->name == str) {
parser.c:		if (hnode->flags & HV_NICKNAME)
parser.c:		if (singular_legal && (hnode->flags & HV_NOUN)) {
parser.c:			state->num_errors < best_num_errors;
parser.c:		    if (!intersect(&objects, &hnode->pv.noun)) {
parser.c:				   start, state->word_index - 1);
parser.c:		    bitvec_copy(&mp->val.obs, &objects);
parser.c:		    mp->ordinal = ordinal;
parser.c:				   start, state->word_index - 1);
parser.c:		if ((ordinal == 0) && (hnode->flags & HV_PLURAL)) {
parser.c:			state->num_errors < best_num_errors;
parser.c:		    if (!intersect(&objects, &hnode->pv.plural)) {
parser.c:				   start, state->word_index - 1);
parser.c:		    bitvec_copy(&mp->val.obs, &objects);
parser.c:		    mp->ordinal = ordinal;
parser.c:				   start, state->word_index - 1);
parser.c:		if (hnode->flags & HV_ADJ) {
parser.c:		    intersect(&objects, &hnode->pv.adj);
parser.c:	    hnode = hnode->next;
parser.c:    while ((tok = parse_vn->token[index++])) {
parser.c:	    if (cnt == which - 1) {
parser.c:		p = strput(p, end, literals[-(tok + 1)]);
parser.c:		if (cnt == which - 1 || ++ocnt >= which
parser.c:    p--;
parser.c:    err->error_type = ERR_ALLOCATED;
parser.c:    err->err.str = string_copy(buf, "make_error_message");
parser.c:/* 1 -> ok
parser.c: * 0 -> no such func
parser.c: * -1 -> returned error
parser.c: * -2 -> generated error
parser.c: * -3 -> abort
parser.c:    if (sv->type == T_NUMBER) {
parser.c:	DEBUG_P(("Return value was: %i", sv->u.number));
parser.c:	if (sv->u.number)
parser.c:	if (state->num_errors == best_num_errors) {
parser.c:	    return -3;
parser.c:	if (state->num_errors++ == 0)
parser.c:	return -2;
parser.c:    if (sv->type != T_STRING) {
parser.c:    DEBUG_P(("Returned string was: %s", sv->u.string));
parser.c:    if (state->num_errors == best_num_errors) {
parser.c:	return -3;
parser.c:    if (state->num_errors++ == 0) {
parser.c:	current_error_info.err.str = string_copy(sv->u.string, "process_answer");
parser.c:    return -1;
parser.c:/* 1 - error or accepted
parser.c: * 0 - no function
parser.c: * -1 - generated or ridiculous error
parser.c:    if (sv->type == T_NUMBER) {
parser.c:	DEBUG_P(("Return value was: %i", sv->u.number));
parser.c:	if (sv->u.number)
parser.c:	if (state->num_errors == 0)
parser.c:	return -1;
parser.c:    if (sv->type != T_STRING) {
parser.c:	DEBUG_P(("Return value was not a string or number.", sv->u.number));
parser.c:    DEBUG_P(("Returned string was: %s", sv->u.string));
parser.c:    if (sv->u.string[0] == '#') {
parser.c:	parallel_error_info.err.str = string_copy(sv->u.string + 1, "process_answer");
parser.c:	return -1;
parser.c:	parallel_error_info.err.str = string_copy(sv->u.string, "process_answer");
parser.c:    while ((tok = parse_vn->token[index++])) {
parser.c:	switch ((tok = vn->token[index++]) & ~CHOOSE_MODIFIER) {
parser.c:		*(p-1) = 0; /* nuke last space */
parser.c:	    p = strput(p, end, literals[-(tok + 1)]);
parser.c:	se = best_result->parallel;
parser.c:	    se = se->next;
parser.c:    for (i = 0; i < bv->last; i++) {
parser.c:	if (bv->b[i]) {
parser.c:		if (bv->b[i] & j)
parser.c:	se = best_result->parallel;
parser.c:	    svalue_t *ret = get_the_error(&se->err, se->obj);
parser.c:		assign_svalue_no_free(&arr->item[i], ret);
parser.c:	    se = se->next;
parser.c:    for (i = 0; i < bv->last; i++) {
parser.c:	if (bv->b[i]) {
parser.c:		if (bv->b[i] & j) {
parser.c:		    n--;
parser.c:		    if (ob->flags & O_DESTRUCTED) {
parser.c:			arr->item[n] = const0u;
parser.c:			arr->item[n].type = T_OBJECT;
parser.c:			arr->item[n].u.ob = ob;
parser.c:	buf = strput(buf, end, parse_verb_entry->match_name);
parser.c:	push_shared_string(parse_verb_entry->match_name);
parser.c:    while ((tok = parse_vn->token[index++])) {
parser.c:	    } else if (loaded_objects[matches[match].val.number]->flags & O_DESTRUCTED) {
parser.c:		buf = strput(buf, end, literals[-(tok + 1)]);
parser.c:		push_shared_string(literals[-(tok + 1)]);
parser.c:#define SET_OB(x) if ((ob = (x))->flags & O_DESTRUCTED) return 0;
parser.c:	    SET_OB(parse_vn->handler);
parser.c:	DEBUG_P(("Trying %s ... (/%s)", func, ob->name));
parser.c:	if (ob->flags & O_DESTRUCTED)
parser.c:	if (ret == -3)
parser.c:	if (state->num_errors == best_num_errors) {
parser.c:	if (state->num_errors++ == 0)
parser.c:	next = se->next;
parser.c:	free_parser_error(&se->err);
parser.c:    if (state->num_errors++ == 0) {
parser.c:    n->next = parallel_errors;
parser.c:    n->obj = ob;
parser.c:    n->err = parallel_error_info;
parser.c:	    SET_OB(parse_vn->handler);
parser.c:	DEBUG_P(("Trying %s ... (/%s)", func, ob->name));
parser.c:	if (ob->flags & O_DESTRUCTED)
parser.c:	if (state->num_errors == 0)
parser.c:    bitvec_t *bv = &m->val.obs;
parser.c:    int ordinal = m->ordinal;
parser.c:    int ord2 = m->ordinal;
parser.c:    int has_ordinal = (m->ordinal != 0);
parser.c:    for (i = 0; i < bv->last; i++) {
parser.c:	if (bv->b[i]) {
parser.c:		if (bv->b[i] & j) {
parser.c:			    ord2--;
parser.c:			    if (ordinal < 0 || --ordinal == 0) {
parser.c:				if (ordinal == -2)
parser.c:				    state->num_errors--;
parser.c:				    m->token = ERROR_TOKEN;
parser.c:				    if (ordinal != -1)
parser.c:				    ordinal = -2;
parser.c:				    m->val.number = BPI * i + k;
parser.c:				    m->token = ERROR_TOKEN;
parser.c:				if (m->token & CHOOSE_MODIFIER) {
parser.c:				    if (match >= 0) m->val.number = match;
parser.c:				match = -1;
parser.c:			if (has_ordinal && (ordinal == -1 || --ord2 == 0)) {
parser.c:			bv->b[i] &= ~j;
parser.c:	    m->val.number = match;
parser.c:	    state->num_errors--;
parser.c:	m->token = ERROR_TOKEN;
parser.c:	if (state->num_errors++ == 0) {
parser.c:	    bitvec_copy(&current_error_info.err.obs, &m->val.obs);
parser.c:	if (ordinal == -2) return;
parser.c:	m->token = ERROR_TOKEN;
parser.c:	if (state->num_errors++ == 0) {
parser.c:    bitvec_t *bv = &m->val.obs;
parser.c:    for (i = 0; i < bv->last; i++) {
parser.c:	if (bv->b[i]) {
parser.c:		if (bv->b[i] & j) {
parser.c:			bv->b[i] &= ~j;
parser.c:	m->token = ERROR_TOKEN;
parser.c:    if (!err->error_type) 
parser.c:    if (state->num_errors++ == 0) {
parser.c:	err->error_type = 0;
parser.c:    bitvec_t *bv = &m->val.obs;
parser.c:    for (i = 0; i < bv->last; i++) {
parser.c:	if (bv->b[i]) {
parser.c:		if (bv->b[i] & j) {
parser.c:			bv->b[i] &= ~j;
parser.c:			if (!found_one) m->val.number = BPI * i + k;
parser.c:	m->token = ERROR_TOKEN;
parser.c: * This function checks if two object can be used together in two-object rule.
parser.c:	/* The same as above - the object can be used for the action,
parser.c: * This function checks if the objects in two-object rule can really 
parser.c:    int i, direct = -1, indirect = -1;
parser.c:    int found_direct = -1, found_indirect = -1;
parser.c:    for (i = 0; i < state->num_matches; i++) {
parser.c:	for (; i < bv->last; i++) {
parser.c:	    if (bv->b[i]) {
parser.c:		    if (bv->b[i] & j) {
parser.c:			if (!--ord) {
parser.c:	    /* there's less indirect objs than specified --> error */
parser.c:	    if (state->num_errors++ == 0) {
parser.c:	    state->num_errors++;
parser.c:    if (!(direct_ordinal = matches[direct].ordinal)) direct_ordinal = -1;
parser.c:    for (i = 0; !finished && i < dir_objs->last; i++) if (dir_objs->b[i]) {
parser.c:	for(j = 1, k = 0; j ; j <<=1, k++) if (dir_objs->b[i] & j) {
parser.c:	    for (l = 0; l < indir_objs->last; l++) if (indir_objs->b[l]) {
parser.c:		for (m = 1, n = 0; m ; m <<= 1, n++) if (indir_objs->b[l] & m) {
parser.c:		    /* indirect unique --> check indirect_ first. */
parser.c:			    if (state->num_errors++ == 0) {
parser.c:		    if (direct_ordinal > 0) direct_ordinal--;
parser.c:			    if (state->num_errors++ == 0) {
parser.c:    if (best_match >= parse_vn->weight) {
parser.c:    if (state->num_errors) {
parser.c:	if (state->num_errors > best_num_errors) {
parser.c:	if (state->num_errors == best_num_errors
parser.c:	    && parse_vn->weight < best_error_match) {
parser.c:    for (which = 1, mtch = 0; which < 3 && mtch < state->num_matches; mtch++) {
parser.c:	else if (state->num_objs == 2)
parser.c:    if (state->num_objs == 2 && !state->num_errors) {
parser.c:    if (state->num_errors) {
parser.c:	int weight = parse_vn->weight;
parser.c:	if (state->num_errors == best_num_errors &&
parser.c:	best_num_errors = state->num_errors;
parser.c:	best_match = parse_vn->weight;
parser.c:	if (parse_vn->handler->flags & O_DESTRUCTED) {
parser.c:	best_result->ob = parse_vn->handler;
parser.c:	best_result->parallel = parallel_errors;
parser.c:	add_ref(parse_vn->handler, "best_result");
parser.c:	    best_result->res[try].func = string_copy(func, "best_result");
parser.c:	    best_result->res[try].num = args;
parser.c:		p = (char *)(best_result->res[try].args = CALLOCATE(args,
parser.c:		memcpy(p, (char *)(sp - args + 1), args * sizeof(svalue_t));
parser.c:		sp -= args;
parser.c:	DEBUG_P(("Saving successful match: %s (%s)", best_result->res[0].func,
parser.c:		 best_result->ob->name));
parser.c:    object_t *ob = best_result->ob;
parser.c:	if (ob->flags & O_DESTRUCTED) return;
parser.c:	n = best_result->res[i].num;
parser.c:	    memcpy((char *)(sp + 1), best_result->res[i].args, n*sizeof(svalue_t));
parser.c:	    while (n--) {
parser.c:		if ((++sp)->type == T_OBJECT && (sp->u.ob->flags & O_DESTRUCTED)) {
parser.c:		    free_object(sp->u.ob, "do_the_call");
parser.c:	    FREE(best_result->res[i].args);
parser.c:	best_result->res[i].args = 0;
parser.c:	DEBUG_P(("Calling %s ...", best_result->res[i].func));
parser.c:	if (apply(best_result->res[i].func, ob,
parser.c:		  best_result->res[i].num, ORIGIN_DRIVER)) return;
parser.c:	  ob->name);
parser.c:	tok = parse_vn->token[state->tok_index++];
parser.c:	if (state->word_index == num_words && tok) {
parser.c:	    if (state->word_index == num_words)
parser.c:		start = state->word_index++;
parser.c:		while (state->word_index <= num_words) {
parser.c:				   start, state->word_index - 1);
parser.c:		    current_error_info.err.str_problem.end = state->word_index - 1;
parser.c:		    state->word_index++;
parser.c:	    if (!parse_vn->token[state->tok_index]) {
parser.c:		start = state->word_index;
parser.c:		state->word_index = num_words;
parser.c:		add_match(state, STR_TOKEN, start, num_words - 1);
parser.c:		start = state->word_index++;
parser.c:		while (state->word_index <= num_words) {
parser.c:			      start, state->word_index - 1);
parser.c:		    state->word_index++;
parser.c:	    add_match(state, WRD_TOKEN, state->word_index, state->word_index);
parser.c:	    state->word_index++;
parser.c:	    if (literals[-(tok + 1)] == words[state->word_index].string) {
parser.c:		state->word_index++;
parser.c:		DEBUG_P(("Matched literal: %s", literals[-(tok + 1)]));
parser.c:		if (state->tok_index == 1) {
parser.c:		switch (parse_vn->token[state->tok_index - 2]) {
parser.c:			while (literals[-(tok + 1)] != words[state->word_index++].string) {
parser.c:			    if (state->word_index == num_words) {
parser.c:			last = &matches[state->num_matches-1];
parser.c:			last->token = ERROR_TOKEN;
parser.c:			last->last = state->word_index-1;
parser.c:			if (state->num_errors++ == 0) {
parser.c:			    current_error_info.err.str_problem.start = last->first;
parser.c:			    current_error_info.err.str_problem.end = state->word_index - 1;
parser.c:    parse_vn = parse_verb_entry->node;
parser.c:	if ((!parse_restricted || parse_vn->handler == parse_restricted)
parser.c:	    && (best_match <= parse_vn->weight))  {
parser.c:	    if ((parse_vn->lit[0] == -1 ||
parser.c:		 (pos = check_literal(parse_vn->lit[0], 1)))
parser.c:		&& (parse_vn->lit[1] == -1 ||
parser.c:		    check_literal(parse_vn->lit[1], pos))) {
parser.c:	parse_vn = parse_vn->next;
parser.c:	    l = iwp[1] - iwp[0] - 1;
parser.c:		words[num_words].end = oend[iwp - iwords - 1];
parser.c:		idx = iwp - iwords;
parser.c:		num_words--;
parser.c:		l = p - buf;
parser.c:		words[num_words].end = oend[iwp - iwords - 1];
parser.c:		idx = iwp - iwords;
parser.c:		num_words--;
parser.c:    char *end = EndOf(buf) - 1; /* space for zero */
parser.c:		inp--;
parser.c:		orig_ends[n] = inp - 1; /* points to where c was */
parser.c:	orig_ends[n] = inp - 2;
parser.c:	    orig_ends[n - 1] = inp - 2;
parser.c:	    orig_ends[0] = inp - 2;
parser.c:		if (ve->real_name == vb) {
parser.c:		    if (ve->flags & VB_IS_SYN)
parser.c:			parse_verb_entry = ((verb_syn_t *)ve)->real;
parser.c:			(parse_verb_entry->flags & VB_HAS_OBJ)) 
parser.c:		    words[0].end = orig_ends[i-1];
parser.c:		ve = ve->next;
parser.c:	starts[i][-1] = ' ';
parser.c:    int tmp = err->error_type;
parser.c:    err->error_type = 0;
parser.c:    if (obj == -1 || (loaded_objects[obj]->flags & O_DESTRUCTED))
parser.c:	push_shared_string(err->err.noun->name);
parser.c:	push_number(get_single(&err->err.noun->pv.noun) == -1);
parser.c:	push_bitvec_as_array(&err->err.obs, 0);
parser.c:	push_number(err->err.ord_error);
parser.c:	push_words(err->err.str_problem.start,
parser.c:		   err->err.str_problem.end);
parser.c:	push_malloced_string(err->err.str);
parser.c:	sp--;
parser.c:	hack.u.number = -found_level;
parser.c:    if (!current_object->pinfo)
parser.c:	      current_object->name);
parser.c:	parse_nicks = (sp--)->u.map;
parser.c:	parse_env = (sp--)->u.arr;
parser.c:    if (st_num_arg >= 2 && (sp--)->u.number) {
parser.c:	if ((sp + 1)->u.number > 1)
parser.c:	error("Parser debugging not enabled. (compile with -DDEBUG or -DPARSE_DEBUG).\n");
parser.c:    sp->type = T_ERROR_HANDLER;
parser.c:    sp->u.error_handler = free_parse_globals;
parser.c:    pi = current_object->pinfo;
parser.c:    parse_sentence((sp-1)->u.string);
parser.c:	sp--; /* pop the error handler */
parser.c:	svalue_t *ret = get_the_error(&best_error_info, -1);
parser.c:	sp--; /* pop the error handler */
parser.c:	    ret->type = T_NUMBER; /* will be freed later */
parser.c:    int flag = (st_num_arg == 3 ? (sp--)->u.number : 0);
parser.c:    if (!(sp-1)->u.ob->pinfo)
parser.c:	      (sp-1)->u.ob->name);
parser.c:    if (!current_object->pinfo)
parser.c:	      current_object->name);
parser.c:    sp->type = T_ERROR_HANDLER;
parser.c:    sp->u.error_handler = free_parse_globals;
parser.c:    parse_user = (sp-2)->u.ob;
parser.c:    pi = parse_user->pinfo;
parser.c:    parse_sentence((sp-1)->u.string);
parser.c:	    sp--; /* pop the error handler */
parser.c:	    free_string_svalue(sp--);
parser.c:	    n = best_result->res[3].num;
parser.c:		memcpy((char *)arr->item, best_result->res[3].args, n*sizeof(svalue_t));
parser.c:		while (n--) {
parser.c:		    if (arr->item[n].type == T_OBJECT && arr->item[n].u.ob->flags & O_DESTRUCTED) {
parser.c:			free_object(arr->item[n].u.ob, "parse_my_rules");
parser.c:			arr->item[n] = const0u;
parser.c:		FREE(best_result->res[3].args);
parser.c:	    best_result->res[3].args = 0;
parser.c:	    sp--; /* pop the error handler */
parser.c:	    free_string_svalue(sp--);
parser.c:	svalue_t *ret = get_the_error(&best_error_info, -1);
parser.c:	sp--; /* pop the error handler */
parser.c:	free_string_svalue(sp--);
parser.c:	    ret->type = T_NUMBER;
parser.c:	if (verb_entry->match_name == verb) {
parser.c:	    verb_node_t **vn = &(verb_entry->node), *old;
parser.c:		if ((*vn)->handler == current_object) {
parser.c:		    *vn = (*vn)->next;
parser.c:		} else vn = &((*vn)->next);
parser.c:	verb_entry = verb_entry->next;
parser.c:    free_string_svalue(sp--);
parser.c:    rule = sp->u.string;
parser.c:    verb = SHARED_STRING(sp-1);
parser.c:    if (!(handler->pinfo))
parser.c:	      handler->name);
parser.c:	    if (verb_entry->match_name == verb &&
parser.c:		verb_entry->real_name == verb &&
parser.c:		!(verb_entry->flags & VB_IS_SYN))
parser.c:	    verb_entry = verb_entry->next;
parser.c:	    verb = make_shared_string((sp-1)->u.string);
parser.c:	verb_entry->real_name = verb;
parser.c:	verb_entry->match_name = verb;
parser.c:	verb_entry->node = 0;
parser.c:	verb_entry->flags = 0;
parser.c:	verb_entry->next = verbs[h];
parser.c:	    lit[j++] = -(tokens[i]+1);
parser.c:	lit[j++] = -1;
parser.c:    verb_node->lit[0] = lit[0];
parser.c:    verb_node->lit[1] = lit[1];
parser.c:	    verb_entry->flags |= VB_HAS_OBJ;
parser.c:	verb_node->token[j] = tokens[j];
parser.c:    verb_node->weight = weight;
parser.c:    verb_node->handler = handler;
parser.c:    handler->pinfo->flags |= PI_VERB_HANDLER;
parser.c:    verb_node->next = verb_entry->node;
parser.c:    verb_entry->node = verb_node;
parser.c:	handler->pinfo->flags |= PI_REMOTE_LIVINGS;
parser.c:    free_string_svalue(sp--);
parser.c:    free_string_svalue(sp--);
parser.c:	orig_new_verb = (sp-2)->u.string;
parser.c:	new_verb = SHARED_STRING(sp-2);
parser.c:	old_verb = SHARED_STRING(sp-1);
parser.c:	rule = sp->u.string;
parser.c:	orig_new_verb = (sp-1)->u.string;
parser.c:	new_verb = SHARED_STRING(sp-1);
parser.c:	if (vb->real_name == old_verb && vb->match_name == old_verb)
parser.c:	vb = vb->next;
parser.c:	    if (verb_entry->real_name == new_verb
parser.c:		&& verb_entry->match_name == old_verb) {
parser.c:		    if ((verb_entry->flags & VB_IS_SYN) == 0) break;
parser.c:		    if ((verb_entry->flags & VB_IS_SYN))
parser.c:	    verb_entry = verb_entry->next;
parser.c:	verb_entry->real_name = new_verb;
parser.c:	verb_entry->match_name = old_verb;
parser.c:	verb_entry->node = 0;
parser.c:	verb_entry->flags = 0;
parser.c:	verb_entry->next = verbs[h];
parser.c:	for (vn = vb->node; vn; vn = vn->next) {
parser.c:		if (vn->token[i] != tokens[i]) break;
parser.c:	    if (!tokens[i] && !vn->token[i]) break; /* match */
parser.c:	if (vn->handler != current_object) error("Rule owned by different object.\n");
parser.c:	for (i = 0; vn->token[i]; i++)
parser.c:	    if (vn->token[i] >= OBJ_A_TOKEN) {
parser.c:		verb_entry->flags |= VB_HAS_OBJ;
parser.c:	verb_node->next = verb_entry->node;
parser.c:	verb_entry->node = verb_node;
parser.c:	syn->flags = VB_IS_SYN | (vb->flags & VB_HAS_OBJ);
parser.c:	syn->real = vb;
parser.c:    if (st_num_arg == 3) free_string_svalue(sp--);
parser.c:    free_string_svalue(sp--);
parser.c:    free_string_svalue(sp--);
parser.c:	for (v = verbs[i]; v; v = v->next) {
parser.c:	    verb_node_t *vn = v->node;
parser.c:	    if (v->real_name == v->match_name)
parser.c:		outbuf_addv(&ob, "Verb %s:\n", v->real_name);
parser.c:		outbuf_addv(&ob, "Verb %s (%s):\n", v->real_name, v->match_name);
parser.c:	    if (v->flags & VB_IS_SYN) {
parser.c:		outbuf_addv(&ob, "  Synonym for: %s\n", ((verb_syn_t *)v)->real->real_name);
parser.c:		outbuf_addv(&ob, "  (/%s) %s\n", vn->handler->name, rule_string(vn));
parser.c:		vn = vn->next;
sockets.c:    arg = sp - num_arg + 1;
sockets.c:    if (check_valid_socket("create", -1, current_object, "N/A", -1)) {
sockets.c:        pop_n_elems(num_arg - 1);
sockets.c:        sp->u.number = fd;
sockets.c:        pop_n_elems(num_arg - 1);
sockets.c:        sp->u.number = EESECURITY;
sockets.c:    arg = sp - num_arg + 1;
sockets.c:	pop_n_elems(num_arg - 1);
sockets.c:        sp->u.number = i;
sockets.c:	pop_n_elems(num_arg - 1);
sockets.c:	sp->u.number = EESECURITY;
sockets.c:    fd = (sp - 1)->u.number;
sockets.c:        sp->u.number = i;
sockets.c:        sp->u.number = EESECURITY;
sockets.c:    if (!(sp->type & (T_STRING | T_FUNCTION))) {
sockets.c:    get_socket_address(fd = (sp-2)->u.number, addr, &port, 0);
sockets.c:    (sp-2)->u.number = VALID_SOCKET("accept") ?
sockets.c:       socket_accept(fd, (sp - 1), sp) :
sockets.c:    if (!((sp - 1)->type & (T_FUNCTION | T_STRING))) {
sockets.c:    if (!(sp->type & (T_FUNCTION | T_STRING))) {
sockets.c:    fd = (sp - 3)->u.number;
sockets.c:	if ((s = strchr((sp - 2)->u.string, ' '))) {
sockets.c:	    i = s - (sp - 2)->u.string;
sockets.c:	    if (i > ADDR_BUF_SIZE - 1) {
sockets.c:		start = i - ADDR_BUF_SIZE - 1;
sockets.c:		i = ADDR_BUF_SIZE - 1;
sockets.c:	    strncat(addr, (sp - 2)->u.string + start, i);
sockets.c:	fprintf(stderr, "socket_connect: requested on: %s\n", (sp - 2)->u.string);
sockets.c:    (sp-3)->u.number = VALID_SOCKET("connect") ?
sockets.c:      socket_connect(fd, (sp - 2)->u.string, sp - 1, sp) : EESECURITY;
sockets.c:    arg = sp - num_arg + 1;
sockets.c:        pop_n_elems(num_arg - 1);
sockets.c:        sp->u.number = i;
sockets.c:        pop_n_elems(num_arg - 1);
sockets.c:        sp->u.number = EESECURITY;
sockets.c:    fd = sp->u.number;
sockets.c:    sp->u.number = VALID_SOCKET("close") ? socket_close(fd, 0) : EESECURITY;
sockets.c:    if (!(sp->type & (T_STRING | T_FUNCTION))) {
sockets.c:    fd = (sp - 2)->u.number;
sockets.c:    (sp-2)->u.number = VALID_SOCKET("release") ?
sockets.c:      socket_release((sp - 2)->u.number, (sp - 1)->u.ob, sp) :
sockets.c:    if (sp->type == T_OBJECT)
sockets.c:	free_object(sp->u.ob, "socket_release()");
sockets.c:    sp--;
sockets.c:    if (!((sp - 1)->type & (T_FUNCTION | T_STRING))) {
sockets.c:    if (!(sp->type & (T_FUNCTION | T_STRING))) {
sockets.c:    fd = (sp - 3)->u.number;
sockets.c:    (sp-3)->u.number = VALID_SOCKET("acquire") ?
sockets.c:      socket_acquire((sp - 3)->u.number, (sp - 2),
sockets.c:		     (sp - 1), sp) : EESECURITY;
sockets.c:    put_constant_string(socket_error(sp->u.number));
sockets.c:    local = (sp--)->u.number;
sockets.c:    if (sp->type & T_OBJECT) {
sockets.c:        if (!sp->u.ob->interactive) {
sockets.c:            free_object(sp->u.ob, "f_socket_address:1");
sockets.c:        tmp = inet_ntoa(sp->u.ob->interactive->addr.sin_addr);
sockets.c:		ntohs(sp->u.ob->interactive->addr.sin_port));
sockets.c:        free_object(sp->u.ob, "f_socket_address:2");
sockets.c:    get_socket_address(sp->u.number, addr, &port, local);
sockets.c:	 info = socket_status(sp->u.number);
sockets.c:	     sp->u.number = 0;
sockets.c:	     sp->type = T_ARRAY;
sockets.c:	     sp->u.arr = info;
sockets.c:	     info->item[i].type = T_ARRAY;
sockets.c:	     info->item[i].u.arr = socket_status(i);
uids.c: *   11-1-92 - Erik Kay - initial creation
uids.c: *   94.07.14 - Robocoder - replaced linked list with AVL tree, and
uids.c:    if (current_object->euid == NULL)
uids.c:    ob = sp->u.ob;
uids.c:    if (ob->euid) {
uids.c:        ob->uid = current_object->euid;
uids.c:    if (sp->type & T_OBJECT) {
uids.c:        ob = sp->u.ob;
uids.c:        if (ob->euid) {
uids.c:            put_constant_string(ob->euid->name);
uids.c:    } else if (sp->type & T_FUNCTION) {
uids.c:        if ((fp = sp->u.fp)->hdr.owner && fp->hdr.owner->euid) {
uids.c:            put_constant_string(fp->hdr.owner->euid->name);
uids.c:    ob = sp->u.ob;
uids.c:    DEBUG_CHECK(ob->uid == NULL, "UID is a null pointer\n");
uids.c:    put_constant_string(ob->uid->name);
uids.c:    if (sp->type & T_NUMBER) {
uids.c:        if (sp->u.number)
uids.c:        current_object->euid = NULL;
uids.c:	sp->u.number = 1;
uids.c:    current_object->euid = add_uid(sp->u.string);
uids.c:    DO_MARK(tr->tree_p, TAG_UID);
uids.c:    EXTRA_REF(BLOCK(((userid_t *)tr->tree_p)->name))++;
uids.c:    if (tr->tree_l)
uids.c:	mark_uid_tree(tr->tree_l);
uids.c:    if (tr->tree_r)
uids.c:	mark_uid_tree(tr->tree_r);
uids.c:    name1 = uid1->name;
uids.c:    name2 = uid2->name;
uids.c:    return (name1 < name2 ? -1 : (name1 > name2 ? 1 : 0));
uids.c:	uid->name = sname;
uids.c:    root_uid->name = make_shared_string(name);
uids.c:    backbone_uid->name = make_shared_string(name);
